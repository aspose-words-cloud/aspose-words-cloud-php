<?php
/*
 * --------------------------------------------------------------------------------
 * <copyright company="Aspose" file="WordsApi.php">
 *   Copyright (c) 2024 Aspose.Words for Cloud
 * </copyright>
 * <summary>
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 * </summary>
 * --------------------------------------------------------------------------------
 */

namespace Aspose\Words;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aspose\Words\Model\Requests;
use phpseclib3\Crypt\PublicKeyLoader;
use phpseclib3\Math\BigInteger;
use phpseclib3\Crypt\RSA;
use Aspose\Words\Encryptor;

/*
 * WordsApi Aspose.Words for Cloud API.
 */
class WordsApi implements Encryptor
{
    /*
     * Stores client instance
     * @var ClientInterface client for calling api
     */
    protected $client;

    /*
     * Stores configuration
     * @var Configuration configuration info
     */
    protected $config;

    /*
     * Stores RSA key
     * @var phpseclib3\Crypt\Common\AsymmetricKey RSA key
     */
    protected $rsaKey;

    /*
     * Initialize a new instance of WordsApi
     * @param string   $clientId client sid
     * @param string   $clientSecret client secret
     * @param string   $baseUrl base url for requests
     */
    public function __construct(string $clientId, string $clientSecret, string $baseUrl = null)
    {
        if (!isset($clientId) || trim($clientId) === '') {
            throw new ApiException('clientId could not be an empty string.');
        }

        if (!isset($clientSecret) || trim($clientSecret) === '') {
            throw new ApiException('clientSecret could not be an empty string.');
        }

        $this->client = new Client();
        $this->config = new Configuration($clientId, $clientSecret);
        $this->config->setEncryptor($this);
        if (!empty($baseUrl))
        {
            $this->config->setHost($baseUrl);
        }
        $this->_checkAuthToken();
    }

    /*
     * Gets the config
     * @return Configuration
     */
    public function getConfig() 
    {
        return $this->config;
    }

    /*
     * Operation acceptAllRevisions
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RevisionsModificationResponse
     */
    public function acceptAllRevisions(Requests\acceptAllRevisionsRequest $request)
    {
        try {
            list($response) = $this->acceptAllRevisionsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->acceptAllRevisionsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation acceptAllRevisionsWithHttpInfo
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RevisionsModificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function acceptAllRevisionsWithHttpInfo(Requests\acceptAllRevisionsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RevisionsModificationResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RevisionsModificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation acceptAllRevisionsAsync
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptAllRevisionsAsync(Requests\acceptAllRevisionsRequest $request) 
    {
        return $this->acceptAllRevisionsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation acceptAllRevisionsAsyncWithHttpInfo
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function acceptAllRevisionsAsyncWithHttpInfo(Requests\acceptAllRevisionsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RevisionsModificationResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation acceptAllRevisionsOnline
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return AcceptAllRevisionsOnlineResponse
     */
    public function acceptAllRevisionsOnline(Requests\acceptAllRevisionsOnlineRequest $request)
    {
        try {
            list($response) = $this->acceptAllRevisionsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->acceptAllRevisionsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation acceptAllRevisionsOnlineWithHttpInfo
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of AcceptAllRevisionsOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function acceptAllRevisionsOnlineWithHttpInfo(Requests\acceptAllRevisionsOnlineRequest $request)
    {
        $returnType = 'AcceptAllRevisionsOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'AcceptAllRevisionsOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation acceptAllRevisionsOnlineAsync
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acceptAllRevisionsOnlineAsync(Requests\acceptAllRevisionsOnlineRequest $request) 
    {
        return $this->acceptAllRevisionsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation acceptAllRevisionsOnlineAsyncWithHttpInfo
     *
     * Accepts all revisions in the document.
     *
     * @param Requests\acceptAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function acceptAllRevisionsOnlineAsyncWithHttpInfo(Requests\acceptAllRevisionsOnlineRequest $request) 
    {
        $returnType = 'AcceptAllRevisionsOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation appendDocument
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function appendDocument(Requests\appendDocumentRequest $request)
    {
        try {
            list($response) = $this->appendDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->appendDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation appendDocumentWithHttpInfo
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function appendDocumentWithHttpInfo(Requests\appendDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation appendDocumentAsync
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appendDocumentAsync(Requests\appendDocumentRequest $request) 
    {
        return $this->appendDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation appendDocumentAsyncWithHttpInfo
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function appendDocumentAsyncWithHttpInfo(Requests\appendDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation appendDocumentOnline
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return AppendDocumentOnlineResponse
     */
    public function appendDocumentOnline(Requests\appendDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->appendDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->appendDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation appendDocumentOnlineWithHttpInfo
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of AppendDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function appendDocumentOnlineWithHttpInfo(Requests\appendDocumentOnlineRequest $request)
    {
        $returnType = 'AppendDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'AppendDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation appendDocumentOnlineAsync
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function appendDocumentOnlineAsync(Requests\appendDocumentOnlineRequest $request) 
    {
        return $this->appendDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation appendDocumentOnlineAsyncWithHttpInfo
     *
     * Appends documents to the original document.
     *
     * @param Requests\appendDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function appendDocumentOnlineAsyncWithHttpInfo(Requests\appendDocumentOnlineRequest $request) 
    {
        $returnType = 'AppendDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation applyStyleToDocumentElement
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\WordsResponse
     */
    public function applyStyleToDocumentElement(Requests\applyStyleToDocumentElementRequest $request)
    {
        try {
            list($response) = $this->applyStyleToDocumentElementWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->applyStyleToDocumentElementWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation applyStyleToDocumentElementWithHttpInfo
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\WordsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function applyStyleToDocumentElementWithHttpInfo(Requests\applyStyleToDocumentElementRequest $request)
    {
        $returnType = '\Aspose\Words\Model\WordsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\WordsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation applyStyleToDocumentElementAsync
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applyStyleToDocumentElementAsync(Requests\applyStyleToDocumentElementRequest $request) 
    {
        return $this->applyStyleToDocumentElementAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation applyStyleToDocumentElementAsyncWithHttpInfo
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function applyStyleToDocumentElementAsyncWithHttpInfo(Requests\applyStyleToDocumentElementRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\WordsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation applyStyleToDocumentElementOnline
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return ApplyStyleToDocumentElementOnlineResponse
     */
    public function applyStyleToDocumentElementOnline(Requests\applyStyleToDocumentElementOnlineRequest $request)
    {
        try {
            list($response) = $this->applyStyleToDocumentElementOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->applyStyleToDocumentElementOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation applyStyleToDocumentElementOnlineWithHttpInfo
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of ApplyStyleToDocumentElementOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function applyStyleToDocumentElementOnlineWithHttpInfo(Requests\applyStyleToDocumentElementOnlineRequest $request)
    {
        $returnType = 'ApplyStyleToDocumentElementOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'ApplyStyleToDocumentElementOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation applyStyleToDocumentElementOnlineAsync
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applyStyleToDocumentElementOnlineAsync(Requests\applyStyleToDocumentElementOnlineRequest $request) 
    {
        return $this->applyStyleToDocumentElementOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation applyStyleToDocumentElementOnlineAsyncWithHttpInfo
     *
     * Applies a style to the document node.
     *
     * @param Requests\applyStyleToDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function applyStyleToDocumentElementOnlineAsyncWithHttpInfo(Requests\applyStyleToDocumentElementOnlineRequest $request) 
    {
        $returnType = 'ApplyStyleToDocumentElementOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation buildReport
     *
     * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function buildReport(Requests\buildReportRequest $request)
    {
        try {
            list($response) = $this->buildReportWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->buildReportWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation buildReportWithHttpInfo
     *
     * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function buildReportWithHttpInfo(Requests\buildReportRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation buildReportAsync
     *
     * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildReportAsync(Requests\buildReportRequest $request) 
    {
        return $this->buildReportAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation buildReportAsyncWithHttpInfo
     *
     * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function buildReportAsyncWithHttpInfo(Requests\buildReportRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation buildReportOnline
     *
     * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function buildReportOnline(Requests\buildReportOnlineRequest $request)
    {
        try {
            list($response) = $this->buildReportOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->buildReportOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation buildReportOnlineWithHttpInfo
     *
     * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function buildReportOnlineWithHttpInfo(Requests\buildReportOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation buildReportOnlineAsync
     *
     * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildReportOnlineAsync(Requests\buildReportOnlineRequest $request) 
    {
        return $this->buildReportOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation buildReportOnlineAsyncWithHttpInfo
     *
     * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
     *
     * @param Requests\buildReportOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function buildReportOnlineAsyncWithHttpInfo(Requests\buildReportOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation classify
     *
     * Runs a multi-class text classification for the specified raw text.
     *
     * @param Requests\classifyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ClassificationResponse
     */
    public function classify(Requests\classifyRequest $request)
    {
        try {
            list($response) = $this->classifyWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->classifyWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation classifyWithHttpInfo
     *
     * Runs a multi-class text classification for the specified raw text.
     *
     * @param Requests\classifyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ClassificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function classifyWithHttpInfo(Requests\classifyRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ClassificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation classifyAsync
     *
     * Runs a multi-class text classification for the specified raw text.
     *
     * @param Requests\classifyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyAsync(Requests\classifyRequest $request) 
    {
        return $this->classifyAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation classifyAsyncWithHttpInfo
     *
     * Runs a multi-class text classification for the specified raw text.
     *
     * @param Requests\classifyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function classifyAsyncWithHttpInfo(Requests\classifyRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation classifyDocument
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ClassificationResponse
     */
    public function classifyDocument(Requests\classifyDocumentRequest $request)
    {
        try {
            list($response) = $this->classifyDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->classifyDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation classifyDocumentWithHttpInfo
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ClassificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function classifyDocumentWithHttpInfo(Requests\classifyDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ClassificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation classifyDocumentAsync
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyDocumentAsync(Requests\classifyDocumentRequest $request) 
    {
        return $this->classifyDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation classifyDocumentAsyncWithHttpInfo
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function classifyDocumentAsyncWithHttpInfo(Requests\classifyDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation classifyDocumentOnline
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ClassificationResponse
     */
    public function classifyDocumentOnline(Requests\classifyDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->classifyDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->classifyDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation classifyDocumentOnlineWithHttpInfo
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ClassificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function classifyDocumentOnlineWithHttpInfo(Requests\classifyDocumentOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ClassificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation classifyDocumentOnlineAsync
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function classifyDocumentOnlineAsync(Requests\classifyDocumentOnlineRequest $request) 
    {
        return $this->classifyDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation classifyDocumentOnlineAsyncWithHttpInfo
     *
     * Runs a multi-class text classification for the document.
     *
     * @param Requests\classifyDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function classifyDocumentOnlineAsyncWithHttpInfo(Requests\classifyDocumentOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ClassificationResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation compareDocument
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function compareDocument(Requests\compareDocumentRequest $request)
    {
        try {
            list($response) = $this->compareDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->compareDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation compareDocumentWithHttpInfo
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function compareDocumentWithHttpInfo(Requests\compareDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation compareDocumentAsync
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compareDocumentAsync(Requests\compareDocumentRequest $request) 
    {
        return $this->compareDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation compareDocumentAsyncWithHttpInfo
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function compareDocumentAsyncWithHttpInfo(Requests\compareDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation compareDocumentOnline
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return CompareDocumentOnlineResponse
     */
    public function compareDocumentOnline(Requests\compareDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->compareDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->compareDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation compareDocumentOnlineWithHttpInfo
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of CompareDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function compareDocumentOnlineWithHttpInfo(Requests\compareDocumentOnlineRequest $request)
    {
        $returnType = 'CompareDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'CompareDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation compareDocumentOnlineAsync
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compareDocumentOnlineAsync(Requests\compareDocumentOnlineRequest $request) 
    {
        return $this->compareDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation compareDocumentOnlineAsyncWithHttpInfo
     *
     * Compares two documents.
     *
     * @param Requests\compareDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function compareDocumentOnlineAsyncWithHttpInfo(Requests\compareDocumentOnlineRequest $request) 
    {
        $returnType = 'CompareDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation compressDocument
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CompressResponse
     */
    public function compressDocument(Requests\compressDocumentRequest $request)
    {
        try {
            list($response) = $this->compressDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->compressDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation compressDocumentWithHttpInfo
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CompressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function compressDocumentWithHttpInfo(Requests\compressDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CompressResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CompressResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation compressDocumentAsync
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compressDocumentAsync(Requests\compressDocumentRequest $request) 
    {
        return $this->compressDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation compressDocumentAsyncWithHttpInfo
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function compressDocumentAsyncWithHttpInfo(Requests\compressDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CompressResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation compressDocumentOnline
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return CompressDocumentOnlineResponse
     */
    public function compressDocumentOnline(Requests\compressDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->compressDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->compressDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation compressDocumentOnlineWithHttpInfo
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of CompressDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function compressDocumentOnlineWithHttpInfo(Requests\compressDocumentOnlineRequest $request)
    {
        $returnType = 'CompressDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'CompressDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation compressDocumentOnlineAsync
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function compressDocumentOnlineAsync(Requests\compressDocumentOnlineRequest $request) 
    {
        return $this->compressDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation compressDocumentOnlineAsyncWithHttpInfo
     *
     * Compress and resize images inside the document.
     * The default settings allows to reduce the size of the document without any visible degradation of images quality.
     *
     * @param Requests\compressDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function compressDocumentOnlineAsyncWithHttpInfo(Requests\compressDocumentOnlineRequest $request) 
    {
        $returnType = 'CompressDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation convertDocument
     *
     * Converts a document on a local drive to the specified format.
     *
     * @param Requests\convertDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function convertDocument(Requests\convertDocumentRequest $request)
    {
        try {
            list($response) = $this->convertDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->convertDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation convertDocumentWithHttpInfo
     *
     * Converts a document on a local drive to the specified format.
     *
     * @param Requests\convertDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function convertDocumentWithHttpInfo(Requests\convertDocumentRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation convertDocumentAsync
     *
     * Converts a document on a local drive to the specified format.
     *
     * @param Requests\convertDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertDocumentAsync(Requests\convertDocumentRequest $request) 
    {
        return $this->convertDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation convertDocumentAsyncWithHttpInfo
     *
     * Converts a document on a local drive to the specified format.
     *
     * @param Requests\convertDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function convertDocumentAsyncWithHttpInfo(Requests\convertDocumentRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation copyFile
     *
     * Copy file.
     *
     * @param Requests\copyFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function copyFile(Requests\copyFileRequest $request)
    {
        try {
    $this->copyFileWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->copyFileWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation copyFileWithHttpInfo
     *
     * Copy file.
     *
     * @param Requests\copyFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function copyFileWithHttpInfo(Requests\copyFileRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation copyFileAsync
     *
     * Copy file.
     *
     * @param Requests\copyFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsync(Requests\copyFileRequest $request) 
    {
        return $this->copyFileAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation copyFileAsyncWithHttpInfo
     *
     * Copy file.
     *
     * @param Requests\copyFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function copyFileAsyncWithHttpInfo(Requests\copyFileRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation copyFolder
     *
     * Copy folder.
     *
     * @param Requests\copyFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function copyFolder(Requests\copyFolderRequest $request)
    {
        try {
    $this->copyFolderWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->copyFolderWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation copyFolderWithHttpInfo
     *
     * Copy folder.
     *
     * @param Requests\copyFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function copyFolderWithHttpInfo(Requests\copyFolderRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation copyFolderAsync
     *
     * Copy folder.
     *
     * @param Requests\copyFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFolderAsync(Requests\copyFolderRequest $request) 
    {
        return $this->copyFolderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation copyFolderAsyncWithHttpInfo
     *
     * Copy folder.
     *
     * @param Requests\copyFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function copyFolderAsyncWithHttpInfo(Requests\copyFolderRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation copyStyle
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function copyStyle(Requests\copyStyleRequest $request)
    {
        try {
            list($response) = $this->copyStyleWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->copyStyleWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation copyStyleWithHttpInfo
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function copyStyleWithHttpInfo(Requests\copyStyleRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation copyStyleAsync
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyStyleAsync(Requests\copyStyleRequest $request) 
    {
        return $this->copyStyleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation copyStyleAsyncWithHttpInfo
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function copyStyleAsyncWithHttpInfo(Requests\copyStyleRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation copyStyleOnline
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return CopyStyleOnlineResponse
     */
    public function copyStyleOnline(Requests\copyStyleOnlineRequest $request)
    {
        try {
            list($response) = $this->copyStyleOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->copyStyleOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation copyStyleOnlineWithHttpInfo
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of CopyStyleOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function copyStyleOnlineWithHttpInfo(Requests\copyStyleOnlineRequest $request)
    {
        $returnType = 'CopyStyleOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'CopyStyleOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation copyStyleOnlineAsync
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyStyleOnlineAsync(Requests\copyStyleOnlineRequest $request) 
    {
        return $this->copyStyleOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation copyStyleOnlineAsyncWithHttpInfo
     *
     * Makes a copy of the style in the document.
     *
     * @param Requests\copyStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function copyStyleOnlineAsyncWithHttpInfo(Requests\copyStyleOnlineRequest $request) 
    {
        $returnType = 'CopyStyleOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation copyStylesFromTemplate
     *
     * Copies styles from the origin document to the target document.
     *
     * @param Requests\copyStylesFromTemplateRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\WordsResponse
     */
    public function copyStylesFromTemplate(Requests\copyStylesFromTemplateRequest $request)
    {
        try {
            list($response) = $this->copyStylesFromTemplateWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->copyStylesFromTemplateWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation copyStylesFromTemplateWithHttpInfo
     *
     * Copies styles from the origin document to the target document.
     *
     * @param Requests\copyStylesFromTemplateRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\WordsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function copyStylesFromTemplateWithHttpInfo(Requests\copyStylesFromTemplateRequest $request)
    {
        $returnType = '\Aspose\Words\Model\WordsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\WordsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation copyStylesFromTemplateAsync
     *
     * Copies styles from the origin document to the target document.
     *
     * @param Requests\copyStylesFromTemplateRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyStylesFromTemplateAsync(Requests\copyStylesFromTemplateRequest $request) 
    {
        return $this->copyStylesFromTemplateAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation copyStylesFromTemplateAsyncWithHttpInfo
     *
     * Copies styles from the origin document to the target document.
     *
     * @param Requests\copyStylesFromTemplateRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function copyStylesFromTemplateAsyncWithHttpInfo(Requests\copyStylesFromTemplateRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\WordsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation createDocument
     *
     * Creates a new document in cloud storage in the format, determined by the file extension.
     * Supported all save format extensions.
     *
     * @param Requests\createDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function createDocument(Requests\createDocumentRequest $request)
    {
        try {
            list($response) = $this->createDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->createDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation createDocumentWithHttpInfo
     *
     * Creates a new document in cloud storage in the format, determined by the file extension.
     * Supported all save format extensions.
     *
     * @param Requests\createDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function createDocumentWithHttpInfo(Requests\createDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation createDocumentAsync
     *
     * Creates a new document in cloud storage in the format, determined by the file extension.
     * Supported all save format extensions.
     *
     * @param Requests\createDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDocumentAsync(Requests\createDocumentRequest $request) 
    {
        return $this->createDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation createDocumentAsyncWithHttpInfo
     *
     * Creates a new document in cloud storage in the format, determined by the file extension.
     * Supported all save format extensions.
     *
     * @param Requests\createDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function createDocumentAsyncWithHttpInfo(Requests\createDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation createFolder
     *
     * Create the folder.
     *
     * @param Requests\createFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createFolder(Requests\createFolderRequest $request)
    {
        try {
    $this->createFolderWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->createFolderWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation createFolderWithHttpInfo
     *
     * Create the folder.
     *
     * @param Requests\createFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function createFolderWithHttpInfo(Requests\createFolderRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation createFolderAsync
     *
     * Create the folder.
     *
     * @param Requests\createFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsync(Requests\createFolderRequest $request) 
    {
        return $this->createFolderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation createFolderAsyncWithHttpInfo
     *
     * Create the folder.
     *
     * @param Requests\createFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function createFolderAsyncWithHttpInfo(Requests\createFolderRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation createOrUpdateDocumentProperty
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentPropertyResponse
     */
    public function createOrUpdateDocumentProperty(Requests\createOrUpdateDocumentPropertyRequest $request)
    {
        try {
            list($response) = $this->createOrUpdateDocumentPropertyWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->createOrUpdateDocumentPropertyWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation createOrUpdateDocumentPropertyWithHttpInfo
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function createOrUpdateDocumentPropertyWithHttpInfo(Requests\createOrUpdateDocumentPropertyRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentPropertyResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation createOrUpdateDocumentPropertyAsync
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateDocumentPropertyAsync(Requests\createOrUpdateDocumentPropertyRequest $request) 
    {
        return $this->createOrUpdateDocumentPropertyAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation createOrUpdateDocumentPropertyAsyncWithHttpInfo
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function createOrUpdateDocumentPropertyAsyncWithHttpInfo(Requests\createOrUpdateDocumentPropertyRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation createOrUpdateDocumentPropertyOnline
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return CreateOrUpdateDocumentPropertyOnlineResponse
     */
    public function createOrUpdateDocumentPropertyOnline(Requests\createOrUpdateDocumentPropertyOnlineRequest $request)
    {
        try {
            list($response) = $this->createOrUpdateDocumentPropertyOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->createOrUpdateDocumentPropertyOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation createOrUpdateDocumentPropertyOnlineWithHttpInfo
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of CreateOrUpdateDocumentPropertyOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function createOrUpdateDocumentPropertyOnlineWithHttpInfo(Requests\createOrUpdateDocumentPropertyOnlineRequest $request)
    {
        $returnType = 'CreateOrUpdateDocumentPropertyOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'CreateOrUpdateDocumentPropertyOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation createOrUpdateDocumentPropertyOnlineAsync
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createOrUpdateDocumentPropertyOnlineAsync(Requests\createOrUpdateDocumentPropertyOnlineRequest $request) 
    {
        return $this->createOrUpdateDocumentPropertyOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation createOrUpdateDocumentPropertyOnlineAsyncWithHttpInfo
     *
     * Adds a new or updates an existing document property.
     *
     * @param Requests\createOrUpdateDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function createOrUpdateDocumentPropertyOnlineAsyncWithHttpInfo(Requests\createOrUpdateDocumentPropertyOnlineRequest $request) 
    {
        $returnType = 'CreateOrUpdateDocumentPropertyOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteAllParagraphTabStops
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TabStopsResponse
     */
    public function deleteAllParagraphTabStops(Requests\deleteAllParagraphTabStopsRequest $request)
    {
        try {
            list($response) = $this->deleteAllParagraphTabStopsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteAllParagraphTabStopsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteAllParagraphTabStopsWithHttpInfo
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TabStopsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteAllParagraphTabStopsWithHttpInfo(Requests\deleteAllParagraphTabStopsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TabStopsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteAllParagraphTabStopsAsync
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParagraphTabStopsAsync(Requests\deleteAllParagraphTabStopsRequest $request) 
    {
        return $this->deleteAllParagraphTabStopsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteAllParagraphTabStopsAsyncWithHttpInfo
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteAllParagraphTabStopsAsyncWithHttpInfo(Requests\deleteAllParagraphTabStopsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteAllParagraphTabStopsOnline
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteAllParagraphTabStopsOnlineResponse
     */
    public function deleteAllParagraphTabStopsOnline(Requests\deleteAllParagraphTabStopsOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteAllParagraphTabStopsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteAllParagraphTabStopsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteAllParagraphTabStopsOnlineWithHttpInfo
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteAllParagraphTabStopsOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteAllParagraphTabStopsOnlineWithHttpInfo(Requests\deleteAllParagraphTabStopsOnlineRequest $request)
    {
        $returnType = 'DeleteAllParagraphTabStopsOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteAllParagraphTabStopsOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteAllParagraphTabStopsOnlineAsync
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllParagraphTabStopsOnlineAsync(Requests\deleteAllParagraphTabStopsOnlineRequest $request) 
    {
        return $this->deleteAllParagraphTabStopsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteAllParagraphTabStopsOnlineAsyncWithHttpInfo
     *
     * Removes paragraph tab stops from the document node.
     *
     * @param Requests\deleteAllParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteAllParagraphTabStopsOnlineAsyncWithHttpInfo(Requests\deleteAllParagraphTabStopsOnlineRequest $request) 
    {
        $returnType = 'DeleteAllParagraphTabStopsOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBookmark
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBookmark(Requests\deleteBookmarkRequest $request)
    {
        try {
    $this->deleteBookmarkWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteBookmarkWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBookmarkWithHttpInfo
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBookmarkWithHttpInfo(Requests\deleteBookmarkRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteBookmarkAsync
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBookmarkAsync(Requests\deleteBookmarkRequest $request) 
    {
        return $this->deleteBookmarkAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBookmarkAsyncWithHttpInfo
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBookmarkAsyncWithHttpInfo(Requests\deleteBookmarkRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBookmarkOnline
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteBookmarkOnline(Requests\deleteBookmarkOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteBookmarkOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBookmarkOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBookmarkOnlineWithHttpInfo
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBookmarkOnlineWithHttpInfo(Requests\deleteBookmarkOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBookmarkOnlineAsync
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBookmarkOnlineAsync(Requests\deleteBookmarkOnlineRequest $request) 
    {
        return $this->deleteBookmarkOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBookmarkOnlineAsyncWithHttpInfo
     *
     * Removes a bookmark from the document.
     *
     * @param Requests\deleteBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBookmarkOnlineAsyncWithHttpInfo(Requests\deleteBookmarkOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBookmarks
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBookmarks(Requests\deleteBookmarksRequest $request)
    {
        try {
    $this->deleteBookmarksWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteBookmarksWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBookmarksWithHttpInfo
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBookmarksWithHttpInfo(Requests\deleteBookmarksRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteBookmarksAsync
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBookmarksAsync(Requests\deleteBookmarksRequest $request) 
    {
        return $this->deleteBookmarksAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBookmarksAsyncWithHttpInfo
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBookmarksAsyncWithHttpInfo(Requests\deleteBookmarksRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBookmarksOnline
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteBookmarksOnline(Requests\deleteBookmarksOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteBookmarksOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBookmarksOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBookmarksOnlineWithHttpInfo
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBookmarksOnlineWithHttpInfo(Requests\deleteBookmarksOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBookmarksOnlineAsync
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBookmarksOnlineAsync(Requests\deleteBookmarksOnlineRequest $request) 
    {
        return $this->deleteBookmarksOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBookmarksOnlineAsyncWithHttpInfo
     *
     * Removes all bookmarks from the document.
     *
     * @param Requests\deleteBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBookmarksOnlineAsyncWithHttpInfo(Requests\deleteBookmarksOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBorder
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BorderResponse
     */
    public function deleteBorder(Requests\deleteBorderRequest $request)
    {
        try {
            list($response) = $this->deleteBorderWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBorderWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBorderWithHttpInfo
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BorderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBorderWithHttpInfo(Requests\deleteBorderRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BorderResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBorderAsync
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBorderAsync(Requests\deleteBorderRequest $request) 
    {
        return $this->deleteBorderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBorderAsyncWithHttpInfo
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBorderAsyncWithHttpInfo(Requests\deleteBorderRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBorderOnline
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteBorderOnlineResponse
     */
    public function deleteBorderOnline(Requests\deleteBorderOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteBorderOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBorderOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBorderOnlineWithHttpInfo
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteBorderOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBorderOnlineWithHttpInfo(Requests\deleteBorderOnlineRequest $request)
    {
        $returnType = 'DeleteBorderOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteBorderOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBorderOnlineAsync
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBorderOnlineAsync(Requests\deleteBorderOnlineRequest $request) 
    {
        return $this->deleteBorderOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBorderOnlineAsyncWithHttpInfo
     *
     * Removes a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBorderOnlineAsyncWithHttpInfo(Requests\deleteBorderOnlineRequest $request) 
    {
        $returnType = 'DeleteBorderOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBorders
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BordersResponse
     */
    public function deleteBorders(Requests\deleteBordersRequest $request)
    {
        try {
            list($response) = $this->deleteBordersWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBordersWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBordersWithHttpInfo
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BordersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBordersWithHttpInfo(Requests\deleteBordersRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BordersResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBordersAsync
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBordersAsync(Requests\deleteBordersRequest $request) 
    {
        return $this->deleteBordersAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBordersAsyncWithHttpInfo
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBordersAsyncWithHttpInfo(Requests\deleteBordersRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteBordersOnline
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteBordersOnlineResponse
     */
    public function deleteBordersOnline(Requests\deleteBordersOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteBordersOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteBordersOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteBordersOnlineWithHttpInfo
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteBordersOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteBordersOnlineWithHttpInfo(Requests\deleteBordersOnlineRequest $request)
    {
        $returnType = 'DeleteBordersOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteBordersOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteBordersOnlineAsync
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBordersOnlineAsync(Requests\deleteBordersOnlineRequest $request) 
    {
        return $this->deleteBordersOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteBordersOnlineAsyncWithHttpInfo
     *
     * Removes borders from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\deleteBordersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteBordersOnlineAsyncWithHttpInfo(Requests\deleteBordersOnlineRequest $request) 
    {
        $returnType = 'DeleteBordersOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteComment
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteComment(Requests\deleteCommentRequest $request)
    {
        try {
    $this->deleteCommentWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteCommentWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCommentWithHttpInfo
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCommentWithHttpInfo(Requests\deleteCommentRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteCommentAsync
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentAsync(Requests\deleteCommentRequest $request) 
    {
        return $this->deleteCommentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCommentAsyncWithHttpInfo
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCommentAsyncWithHttpInfo(Requests\deleteCommentRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCommentOnline
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteCommentOnline(Requests\deleteCommentOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteCommentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteCommentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCommentOnlineWithHttpInfo
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCommentOnlineWithHttpInfo(Requests\deleteCommentOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteCommentOnlineAsync
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentOnlineAsync(Requests\deleteCommentOnlineRequest $request) 
    {
        return $this->deleteCommentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCommentOnlineAsyncWithHttpInfo
     *
     * Removes a comment from the document.
     *
     * @param Requests\deleteCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCommentOnlineAsyncWithHttpInfo(Requests\deleteCommentOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteComments
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteComments(Requests\deleteCommentsRequest $request)
    {
        try {
    $this->deleteCommentsWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteCommentsWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCommentsWithHttpInfo
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCommentsWithHttpInfo(Requests\deleteCommentsRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteCommentsAsync
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentsAsync(Requests\deleteCommentsRequest $request) 
    {
        return $this->deleteCommentsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCommentsAsyncWithHttpInfo
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCommentsAsyncWithHttpInfo(Requests\deleteCommentsRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCommentsOnline
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteCommentsOnline(Requests\deleteCommentsOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteCommentsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteCommentsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCommentsOnlineWithHttpInfo
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCommentsOnlineWithHttpInfo(Requests\deleteCommentsOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteCommentsOnlineAsync
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCommentsOnlineAsync(Requests\deleteCommentsOnlineRequest $request) 
    {
        return $this->deleteCommentsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCommentsOnlineAsyncWithHttpInfo
     *
     * Removes all comments from the document.
     *
     * @param Requests\deleteCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCommentsOnlineAsyncWithHttpInfo(Requests\deleteCommentsOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCustomXmlPart
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomXmlPart(Requests\deleteCustomXmlPartRequest $request)
    {
        try {
    $this->deleteCustomXmlPartWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteCustomXmlPartWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCustomXmlPartWithHttpInfo
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCustomXmlPartWithHttpInfo(Requests\deleteCustomXmlPartRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteCustomXmlPartAsync
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomXmlPartAsync(Requests\deleteCustomXmlPartRequest $request) 
    {
        return $this->deleteCustomXmlPartAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartAsyncWithHttpInfo
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCustomXmlPartAsyncWithHttpInfo(Requests\deleteCustomXmlPartRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartOnline
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteCustomXmlPartOnline(Requests\deleteCustomXmlPartOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteCustomXmlPartOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteCustomXmlPartOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCustomXmlPartOnlineWithHttpInfo
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCustomXmlPartOnlineWithHttpInfo(Requests\deleteCustomXmlPartOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteCustomXmlPartOnlineAsync
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomXmlPartOnlineAsync(Requests\deleteCustomXmlPartOnlineRequest $request) 
    {
        return $this->deleteCustomXmlPartOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartOnlineAsyncWithHttpInfo
     *
     * Removes the custom xml part from the document.
     *
     * @param Requests\deleteCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCustomXmlPartOnlineAsyncWithHttpInfo(Requests\deleteCustomXmlPartOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCustomXmlParts
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomXmlParts(Requests\deleteCustomXmlPartsRequest $request)
    {
        try {
    $this->deleteCustomXmlPartsWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteCustomXmlPartsWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCustomXmlPartsWithHttpInfo
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCustomXmlPartsWithHttpInfo(Requests\deleteCustomXmlPartsRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteCustomXmlPartsAsync
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomXmlPartsAsync(Requests\deleteCustomXmlPartsRequest $request) 
    {
        return $this->deleteCustomXmlPartsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartsAsyncWithHttpInfo
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCustomXmlPartsAsyncWithHttpInfo(Requests\deleteCustomXmlPartsRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartsOnline
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteCustomXmlPartsOnline(Requests\deleteCustomXmlPartsOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteCustomXmlPartsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteCustomXmlPartsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteCustomXmlPartsOnlineWithHttpInfo
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteCustomXmlPartsOnlineWithHttpInfo(Requests\deleteCustomXmlPartsOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteCustomXmlPartsOnlineAsync
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomXmlPartsOnlineAsync(Requests\deleteCustomXmlPartsOnlineRequest $request) 
    {
        return $this->deleteCustomXmlPartsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteCustomXmlPartsOnlineAsyncWithHttpInfo
     *
     * Removes all custom xml parts from the document.
     *
     * @param Requests\deleteCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteCustomXmlPartsOnlineAsyncWithHttpInfo(Requests\deleteCustomXmlPartsOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteDocumentProperty
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDocumentProperty(Requests\deleteDocumentPropertyRequest $request)
    {
        try {
    $this->deleteDocumentPropertyWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteDocumentPropertyWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteDocumentPropertyWithHttpInfo
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteDocumentPropertyWithHttpInfo(Requests\deleteDocumentPropertyRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteDocumentPropertyAsync
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentPropertyAsync(Requests\deleteDocumentPropertyRequest $request) 
    {
        return $this->deleteDocumentPropertyAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteDocumentPropertyAsyncWithHttpInfo
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteDocumentPropertyAsyncWithHttpInfo(Requests\deleteDocumentPropertyRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteDocumentPropertyOnline
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteDocumentPropertyOnline(Requests\deleteDocumentPropertyOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteDocumentPropertyOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteDocumentPropertyOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteDocumentPropertyOnlineWithHttpInfo
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteDocumentPropertyOnlineWithHttpInfo(Requests\deleteDocumentPropertyOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteDocumentPropertyOnlineAsync
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDocumentPropertyOnlineAsync(Requests\deleteDocumentPropertyOnlineRequest $request) 
    {
        return $this->deleteDocumentPropertyOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteDocumentPropertyOnlineAsyncWithHttpInfo
     *
     * Removes a document property.
     *
     * @param Requests\deleteDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteDocumentPropertyOnlineAsyncWithHttpInfo(Requests\deleteDocumentPropertyOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteDrawingObject
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDrawingObject(Requests\deleteDrawingObjectRequest $request)
    {
        try {
    $this->deleteDrawingObjectWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteDrawingObjectWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteDrawingObjectWithHttpInfo
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteDrawingObjectWithHttpInfo(Requests\deleteDrawingObjectRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteDrawingObjectAsync
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDrawingObjectAsync(Requests\deleteDrawingObjectRequest $request) 
    {
        return $this->deleteDrawingObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteDrawingObjectAsyncWithHttpInfo
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteDrawingObjectAsyncWithHttpInfo(Requests\deleteDrawingObjectRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteDrawingObjectOnline
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteDrawingObjectOnline(Requests\deleteDrawingObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteDrawingObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteDrawingObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteDrawingObjectOnlineWithHttpInfo
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteDrawingObjectOnlineWithHttpInfo(Requests\deleteDrawingObjectOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteDrawingObjectOnlineAsync
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDrawingObjectOnlineAsync(Requests\deleteDrawingObjectOnlineRequest $request) 
    {
        return $this->deleteDrawingObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteDrawingObjectOnlineAsyncWithHttpInfo
     *
     * Removes a DrawingObject from the document node.
     *
     * @param Requests\deleteDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteDrawingObjectOnlineAsyncWithHttpInfo(Requests\deleteDrawingObjectOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteField
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteField(Requests\deleteFieldRequest $request)
    {
        try {
    $this->deleteFieldWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFieldWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFieldWithHttpInfo
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFieldWithHttpInfo(Requests\deleteFieldRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFieldAsync
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync(Requests\deleteFieldRequest $request) 
    {
        return $this->deleteFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFieldAsyncWithHttpInfo(Requests\deleteFieldRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFieldOnline
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteFieldOnline(Requests\deleteFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFieldOnlineWithHttpInfo
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFieldOnlineWithHttpInfo(Requests\deleteFieldOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteFieldOnlineAsync
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldOnlineAsync(Requests\deleteFieldOnlineRequest $request) 
    {
        return $this->deleteFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFieldOnlineAsyncWithHttpInfo
     *
     * Removes a field from the document node.
     *
     * @param Requests\deleteFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFieldOnlineAsyncWithHttpInfo(Requests\deleteFieldOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFields
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFields(Requests\deleteFieldsRequest $request)
    {
        try {
    $this->deleteFieldsWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFieldsWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFieldsWithHttpInfo
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFieldsWithHttpInfo(Requests\deleteFieldsRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFieldsAsync
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldsAsync(Requests\deleteFieldsRequest $request) 
    {
        return $this->deleteFieldsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFieldsAsyncWithHttpInfo
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFieldsAsyncWithHttpInfo(Requests\deleteFieldsRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFieldsOnline
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteFieldsOnline(Requests\deleteFieldsOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteFieldsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteFieldsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFieldsOnlineWithHttpInfo
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFieldsOnlineWithHttpInfo(Requests\deleteFieldsOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteFieldsOnlineAsync
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldsOnlineAsync(Requests\deleteFieldsOnlineRequest $request) 
    {
        return $this->deleteFieldsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFieldsOnlineAsyncWithHttpInfo
     *
     * Removes fields from the document node.
     *
     * @param Requests\deleteFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFieldsOnlineAsyncWithHttpInfo(Requests\deleteFieldsOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFile
     *
     * Delete file.
     *
     * @param Requests\deleteFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFile(Requests\deleteFileRequest $request)
    {
        try {
    $this->deleteFileWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFileWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFileWithHttpInfo
     *
     * Delete file.
     *
     * @param Requests\deleteFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFileWithHttpInfo(Requests\deleteFileRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFileAsync
     *
     * Delete file.
     *
     * @param Requests\deleteFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync(Requests\deleteFileRequest $request) 
    {
        return $this->deleteFileAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFileAsyncWithHttpInfo
     *
     * Delete file.
     *
     * @param Requests\deleteFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFileAsyncWithHttpInfo(Requests\deleteFileRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFolder
     *
     * Delete folder.
     *
     * @param Requests\deleteFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFolder(Requests\deleteFolderRequest $request)
    {
        try {
    $this->deleteFolderWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFolderWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFolderWithHttpInfo
     *
     * Delete folder.
     *
     * @param Requests\deleteFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFolderWithHttpInfo(Requests\deleteFolderRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFolderAsync
     *
     * Delete folder.
     *
     * @param Requests\deleteFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync(Requests\deleteFolderRequest $request) 
    {
        return $this->deleteFolderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Delete folder.
     *
     * @param Requests\deleteFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFolderAsyncWithHttpInfo(Requests\deleteFolderRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFootnote
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFootnote(Requests\deleteFootnoteRequest $request)
    {
        try {
    $this->deleteFootnoteWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFootnoteWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFootnoteWithHttpInfo
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFootnoteWithHttpInfo(Requests\deleteFootnoteRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFootnoteAsync
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFootnoteAsync(Requests\deleteFootnoteRequest $request) 
    {
        return $this->deleteFootnoteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFootnoteAsyncWithHttpInfo
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFootnoteAsyncWithHttpInfo(Requests\deleteFootnoteRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFootnoteOnline
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteFootnoteOnline(Requests\deleteFootnoteOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteFootnoteOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteFootnoteOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFootnoteOnlineWithHttpInfo
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFootnoteOnlineWithHttpInfo(Requests\deleteFootnoteOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteFootnoteOnlineAsync
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFootnoteOnlineAsync(Requests\deleteFootnoteOnlineRequest $request) 
    {
        return $this->deleteFootnoteOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFootnoteOnlineAsyncWithHttpInfo
     *
     * Removes a footnote from the document node.
     *
     * @param Requests\deleteFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFootnoteOnlineAsyncWithHttpInfo(Requests\deleteFootnoteOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFormField
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFormField(Requests\deleteFormFieldRequest $request)
    {
        try {
    $this->deleteFormFieldWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteFormFieldWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFormFieldWithHttpInfo
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFormFieldWithHttpInfo(Requests\deleteFormFieldRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteFormFieldAsync
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFormFieldAsync(Requests\deleteFormFieldRequest $request) 
    {
        return $this->deleteFormFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFormFieldAsyncWithHttpInfo
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFormFieldAsyncWithHttpInfo(Requests\deleteFormFieldRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteFormFieldOnline
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteFormFieldOnline(Requests\deleteFormFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteFormFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteFormFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteFormFieldOnlineWithHttpInfo
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteFormFieldOnlineWithHttpInfo(Requests\deleteFormFieldOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteFormFieldOnlineAsync
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFormFieldOnlineAsync(Requests\deleteFormFieldOnlineRequest $request) 
    {
        return $this->deleteFormFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteFormFieldOnlineAsyncWithHttpInfo
     *
     * Removes a form field from the document node.
     *
     * @param Requests\deleteFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteFormFieldOnlineAsyncWithHttpInfo(Requests\deleteFormFieldOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteHeaderFooter
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteHeaderFooter(Requests\deleteHeaderFooterRequest $request)
    {
        try {
    $this->deleteHeaderFooterWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteHeaderFooterWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteHeaderFooterWithHttpInfo
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteHeaderFooterWithHttpInfo(Requests\deleteHeaderFooterRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteHeaderFooterAsync
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHeaderFooterAsync(Requests\deleteHeaderFooterRequest $request) 
    {
        return $this->deleteHeaderFooterAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteHeaderFooterAsyncWithHttpInfo
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteHeaderFooterAsyncWithHttpInfo(Requests\deleteHeaderFooterRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteHeaderFooterOnline
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteHeaderFooterOnline(Requests\deleteHeaderFooterOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteHeaderFooterOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteHeaderFooterOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteHeaderFooterOnlineWithHttpInfo
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteHeaderFooterOnlineWithHttpInfo(Requests\deleteHeaderFooterOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteHeaderFooterOnlineAsync
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHeaderFooterOnlineAsync(Requests\deleteHeaderFooterOnlineRequest $request) 
    {
        return $this->deleteHeaderFooterOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteHeaderFooterOnlineAsyncWithHttpInfo
     *
     * Removes a HeaderFooter object from the document section.
     *
     * @param Requests\deleteHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteHeaderFooterOnlineAsyncWithHttpInfo(Requests\deleteHeaderFooterOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteHeadersFooters
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteHeadersFooters(Requests\deleteHeadersFootersRequest $request)
    {
        try {
    $this->deleteHeadersFootersWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteHeadersFootersWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteHeadersFootersWithHttpInfo
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteHeadersFootersWithHttpInfo(Requests\deleteHeadersFootersRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteHeadersFootersAsync
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHeadersFootersAsync(Requests\deleteHeadersFootersRequest $request) 
    {
        return $this->deleteHeadersFootersAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteHeadersFootersAsyncWithHttpInfo
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteHeadersFootersAsyncWithHttpInfo(Requests\deleteHeadersFootersRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteHeadersFootersOnline
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteHeadersFootersOnline(Requests\deleteHeadersFootersOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteHeadersFootersOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteHeadersFootersOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteHeadersFootersOnlineWithHttpInfo
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteHeadersFootersOnlineWithHttpInfo(Requests\deleteHeadersFootersOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteHeadersFootersOnlineAsync
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteHeadersFootersOnlineAsync(Requests\deleteHeadersFootersOnlineRequest $request) 
    {
        return $this->deleteHeadersFootersOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteHeadersFootersOnlineAsyncWithHttpInfo
     *
     * Removes HeaderFooter objects from the document section.
     *
     * @param Requests\deleteHeadersFootersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteHeadersFootersOnlineAsyncWithHttpInfo(Requests\deleteHeadersFootersOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteMacros
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteMacros(Requests\deleteMacrosRequest $request)
    {
        try {
    $this->deleteMacrosWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteMacrosWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteMacrosWithHttpInfo
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteMacrosWithHttpInfo(Requests\deleteMacrosRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteMacrosAsync
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMacrosAsync(Requests\deleteMacrosRequest $request) 
    {
        return $this->deleteMacrosAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteMacrosAsyncWithHttpInfo
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteMacrosAsyncWithHttpInfo(Requests\deleteMacrosRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteMacrosOnline
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteMacrosOnline(Requests\deleteMacrosOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteMacrosOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteMacrosOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteMacrosOnlineWithHttpInfo
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteMacrosOnlineWithHttpInfo(Requests\deleteMacrosOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteMacrosOnlineAsync
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMacrosOnlineAsync(Requests\deleteMacrosOnlineRequest $request) 
    {
        return $this->deleteMacrosOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteMacrosOnlineAsyncWithHttpInfo
     *
     * Removes macros from the document.
     *
     * @param Requests\deleteMacrosOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteMacrosOnlineAsyncWithHttpInfo(Requests\deleteMacrosOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteOfficeMathObject
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOfficeMathObject(Requests\deleteOfficeMathObjectRequest $request)
    {
        try {
    $this->deleteOfficeMathObjectWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteOfficeMathObjectWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteOfficeMathObjectWithHttpInfo
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteOfficeMathObjectWithHttpInfo(Requests\deleteOfficeMathObjectRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteOfficeMathObjectAsync
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfficeMathObjectAsync(Requests\deleteOfficeMathObjectRequest $request) 
    {
        return $this->deleteOfficeMathObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectAsyncWithHttpInfo
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteOfficeMathObjectAsyncWithHttpInfo(Requests\deleteOfficeMathObjectRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectOnline
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteOfficeMathObjectOnline(Requests\deleteOfficeMathObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteOfficeMathObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteOfficeMathObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteOfficeMathObjectOnlineWithHttpInfo
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteOfficeMathObjectOnlineWithHttpInfo(Requests\deleteOfficeMathObjectOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteOfficeMathObjectOnlineAsync
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfficeMathObjectOnlineAsync(Requests\deleteOfficeMathObjectOnlineRequest $request) 
    {
        return $this->deleteOfficeMathObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectOnlineAsyncWithHttpInfo
     *
     * Removes an OfficeMath object from the document node.
     *
     * @param Requests\deleteOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteOfficeMathObjectOnlineAsyncWithHttpInfo(Requests\deleteOfficeMathObjectOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjects
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteOfficeMathObjects(Requests\deleteOfficeMathObjectsRequest $request)
    {
        try {
    $this->deleteOfficeMathObjectsWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteOfficeMathObjectsWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteOfficeMathObjectsWithHttpInfo
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteOfficeMathObjectsWithHttpInfo(Requests\deleteOfficeMathObjectsRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteOfficeMathObjectsAsync
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfficeMathObjectsAsync(Requests\deleteOfficeMathObjectsRequest $request) 
    {
        return $this->deleteOfficeMathObjectsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectsAsyncWithHttpInfo
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteOfficeMathObjectsAsyncWithHttpInfo(Requests\deleteOfficeMathObjectsRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectsOnline
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteOfficeMathObjectsOnline(Requests\deleteOfficeMathObjectsOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteOfficeMathObjectsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteOfficeMathObjectsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteOfficeMathObjectsOnlineWithHttpInfo
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteOfficeMathObjectsOnlineWithHttpInfo(Requests\deleteOfficeMathObjectsOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteOfficeMathObjectsOnlineAsync
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteOfficeMathObjectsOnlineAsync(Requests\deleteOfficeMathObjectsOnlineRequest $request) 
    {
        return $this->deleteOfficeMathObjectsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteOfficeMathObjectsOnlineAsyncWithHttpInfo
     *
     * Removes all office math objects from the document.
     *
     * @param Requests\deleteOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteOfficeMathObjectsOnlineAsyncWithHttpInfo(Requests\deleteOfficeMathObjectsOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraph
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteParagraph(Requests\deleteParagraphRequest $request)
    {
        try {
    $this->deleteParagraphWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteParagraphWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphWithHttpInfo
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphWithHttpInfo(Requests\deleteParagraphRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphAsync
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphAsync(Requests\deleteParagraphRequest $request) 
    {
        return $this->deleteParagraphAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphAsyncWithHttpInfo
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphAsyncWithHttpInfo(Requests\deleteParagraphRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraphListFormat
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphListFormatResponse
     */
    public function deleteParagraphListFormat(Requests\deleteParagraphListFormatRequest $request)
    {
        try {
            list($response) = $this->deleteParagraphListFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteParagraphListFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphListFormatWithHttpInfo
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphListFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphListFormatWithHttpInfo(Requests\deleteParagraphListFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphListFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphListFormatAsync
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphListFormatAsync(Requests\deleteParagraphListFormatRequest $request) 
    {
        return $this->deleteParagraphListFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphListFormatAsyncWithHttpInfo
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphListFormatAsyncWithHttpInfo(Requests\deleteParagraphListFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraphListFormatOnline
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteParagraphListFormatOnlineResponse
     */
    public function deleteParagraphListFormatOnline(Requests\deleteParagraphListFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteParagraphListFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteParagraphListFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphListFormatOnlineWithHttpInfo
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteParagraphListFormatOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphListFormatOnlineWithHttpInfo(Requests\deleteParagraphListFormatOnlineRequest $request)
    {
        $returnType = 'DeleteParagraphListFormatOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteParagraphListFormatOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphListFormatOnlineAsync
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphListFormatOnlineAsync(Requests\deleteParagraphListFormatOnlineRequest $request) 
    {
        return $this->deleteParagraphListFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphListFormatOnlineAsyncWithHttpInfo
     *
     * Removes the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\deleteParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphListFormatOnlineAsyncWithHttpInfo(Requests\deleteParagraphListFormatOnlineRequest $request) 
    {
        $returnType = 'DeleteParagraphListFormatOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraphOnline
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteParagraphOnline(Requests\deleteParagraphOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteParagraphOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteParagraphOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphOnlineWithHttpInfo
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphOnlineWithHttpInfo(Requests\deleteParagraphOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphOnlineAsync
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphOnlineAsync(Requests\deleteParagraphOnlineRequest $request) 
    {
        return $this->deleteParagraphOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphOnlineAsyncWithHttpInfo
     *
     * Removes a paragraph from the document node.
     *
     * @param Requests\deleteParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphOnlineAsyncWithHttpInfo(Requests\deleteParagraphOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraphTabStop
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TabStopsResponse
     */
    public function deleteParagraphTabStop(Requests\deleteParagraphTabStopRequest $request)
    {
        try {
            list($response) = $this->deleteParagraphTabStopWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteParagraphTabStopWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphTabStopWithHttpInfo
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TabStopsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphTabStopWithHttpInfo(Requests\deleteParagraphTabStopRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TabStopsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphTabStopAsync
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphTabStopAsync(Requests\deleteParagraphTabStopRequest $request) 
    {
        return $this->deleteParagraphTabStopAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphTabStopAsyncWithHttpInfo
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphTabStopAsyncWithHttpInfo(Requests\deleteParagraphTabStopRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteParagraphTabStopOnline
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteParagraphTabStopOnlineResponse
     */
    public function deleteParagraphTabStopOnline(Requests\deleteParagraphTabStopOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteParagraphTabStopOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteParagraphTabStopOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteParagraphTabStopOnlineWithHttpInfo
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteParagraphTabStopOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteParagraphTabStopOnlineWithHttpInfo(Requests\deleteParagraphTabStopOnlineRequest $request)
    {
        $returnType = 'DeleteParagraphTabStopOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteParagraphTabStopOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteParagraphTabStopOnlineAsync
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteParagraphTabStopOnlineAsync(Requests\deleteParagraphTabStopOnlineRequest $request) 
    {
        return $this->deleteParagraphTabStopOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteParagraphTabStopOnlineAsyncWithHttpInfo
     *
     * Removes a paragraph tab stop from the document node.
     *
     * @param Requests\deleteParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteParagraphTabStopOnlineAsyncWithHttpInfo(Requests\deleteParagraphTabStopOnlineRequest $request) 
    {
        $returnType = 'DeleteParagraphTabStopOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteRun
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteRun(Requests\deleteRunRequest $request)
    {
        try {
    $this->deleteRunWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteRunWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteRunWithHttpInfo
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteRunWithHttpInfo(Requests\deleteRunRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteRunAsync
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRunAsync(Requests\deleteRunRequest $request) 
    {
        return $this->deleteRunAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteRunAsyncWithHttpInfo
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteRunAsyncWithHttpInfo(Requests\deleteRunRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteRunOnline
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteRunOnline(Requests\deleteRunOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteRunOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteRunOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteRunOnlineWithHttpInfo
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteRunOnlineWithHttpInfo(Requests\deleteRunOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteRunOnlineAsync
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRunOnlineAsync(Requests\deleteRunOnlineRequest $request) 
    {
        return $this->deleteRunOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteRunOnlineAsyncWithHttpInfo
     *
     * Removes a Run object from the paragraph.
     *
     * @param Requests\deleteRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteRunOnlineAsyncWithHttpInfo(Requests\deleteRunOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteSection
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSection(Requests\deleteSectionRequest $request)
    {
        try {
    $this->deleteSectionWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteSectionWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteSectionWithHttpInfo
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteSectionWithHttpInfo(Requests\deleteSectionRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteSectionAsync
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSectionAsync(Requests\deleteSectionRequest $request) 
    {
        return $this->deleteSectionAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteSectionAsyncWithHttpInfo
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteSectionAsyncWithHttpInfo(Requests\deleteSectionRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteSectionOnline
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteSectionOnline(Requests\deleteSectionOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteSectionOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteSectionOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteSectionOnlineWithHttpInfo
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteSectionOnlineWithHttpInfo(Requests\deleteSectionOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteSectionOnlineAsync
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSectionOnlineAsync(Requests\deleteSectionOnlineRequest $request) 
    {
        return $this->deleteSectionOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteSectionOnlineAsyncWithHttpInfo
     *
     * Removes a section from the document.
     *
     * @param Requests\deleteSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteSectionOnlineAsyncWithHttpInfo(Requests\deleteSectionOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteStructuredDocumentTag
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteStructuredDocumentTag(Requests\deleteStructuredDocumentTagRequest $request)
    {
        try {
    $this->deleteStructuredDocumentTagWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteStructuredDocumentTagWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteStructuredDocumentTagWithHttpInfo
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteStructuredDocumentTagWithHttpInfo(Requests\deleteStructuredDocumentTagRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteStructuredDocumentTagAsync
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStructuredDocumentTagAsync(Requests\deleteStructuredDocumentTagRequest $request) 
    {
        return $this->deleteStructuredDocumentTagAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteStructuredDocumentTagAsyncWithHttpInfo
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteStructuredDocumentTagAsyncWithHttpInfo(Requests\deleteStructuredDocumentTagRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteStructuredDocumentTagOnline
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteStructuredDocumentTagOnline(Requests\deleteStructuredDocumentTagOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteStructuredDocumentTagOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteStructuredDocumentTagOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteStructuredDocumentTagOnlineWithHttpInfo
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteStructuredDocumentTagOnlineWithHttpInfo(Requests\deleteStructuredDocumentTagOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteStructuredDocumentTagOnlineAsync
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStructuredDocumentTagOnlineAsync(Requests\deleteStructuredDocumentTagOnlineRequest $request) 
    {
        return $this->deleteStructuredDocumentTagOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteStructuredDocumentTagOnlineAsyncWithHttpInfo
     *
     * Removes a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\deleteStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteStructuredDocumentTagOnlineAsyncWithHttpInfo(Requests\deleteStructuredDocumentTagOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTable
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTable(Requests\deleteTableRequest $request)
    {
        try {
    $this->deleteTableWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteTableWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableWithHttpInfo
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableWithHttpInfo(Requests\deleteTableRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteTableAsync
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableAsync(Requests\deleteTableRequest $request) 
    {
        return $this->deleteTableAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableAsyncWithHttpInfo
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableAsyncWithHttpInfo(Requests\deleteTableRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTableCell
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTableCell(Requests\deleteTableCellRequest $request)
    {
        try {
    $this->deleteTableCellWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteTableCellWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableCellWithHttpInfo
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableCellWithHttpInfo(Requests\deleteTableCellRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteTableCellAsync
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableCellAsync(Requests\deleteTableCellRequest $request) 
    {
        return $this->deleteTableCellAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableCellAsyncWithHttpInfo
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableCellAsyncWithHttpInfo(Requests\deleteTableCellRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTableCellOnline
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteTableCellOnline(Requests\deleteTableCellOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteTableCellOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteTableCellOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableCellOnlineWithHttpInfo
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableCellOnlineWithHttpInfo(Requests\deleteTableCellOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteTableCellOnlineAsync
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableCellOnlineAsync(Requests\deleteTableCellOnlineRequest $request) 
    {
        return $this->deleteTableCellOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableCellOnlineAsyncWithHttpInfo
     *
     * Removes a cell from the table row.
     *
     * @param Requests\deleteTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableCellOnlineAsyncWithHttpInfo(Requests\deleteTableCellOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTableOnline
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteTableOnline(Requests\deleteTableOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteTableOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteTableOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableOnlineWithHttpInfo
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableOnlineWithHttpInfo(Requests\deleteTableOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteTableOnlineAsync
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableOnlineAsync(Requests\deleteTableOnlineRequest $request) 
    {
        return $this->deleteTableOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableOnlineAsyncWithHttpInfo
     *
     * Removes a table from the document node.
     *
     * @param Requests\deleteTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableOnlineAsyncWithHttpInfo(Requests\deleteTableOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTableRow
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTableRow(Requests\deleteTableRowRequest $request)
    {
        try {
    $this->deleteTableRowWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->deleteTableRowWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableRowWithHttpInfo
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableRowWithHttpInfo(Requests\deleteTableRowRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation deleteTableRowAsync
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableRowAsync(Requests\deleteTableRowRequest $request) 
    {
        return $this->deleteTableRowAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableRowAsyncWithHttpInfo
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableRowAsyncWithHttpInfo(Requests\deleteTableRowRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteTableRowOnline
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function deleteTableRowOnline(Requests\deleteTableRowOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteTableRowOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteTableRowOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteTableRowOnlineWithHttpInfo
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteTableRowOnlineWithHttpInfo(Requests\deleteTableRowOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteTableRowOnlineAsync
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableRowOnlineAsync(Requests\deleteTableRowOnlineRequest $request) 
    {
        return $this->deleteTableRowOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteTableRowOnlineAsyncWithHttpInfo
     *
     * Removes a row from the table.
     *
     * @param Requests\deleteTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteTableRowOnlineAsyncWithHttpInfo(Requests\deleteTableRowOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteWatermark
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function deleteWatermark(Requests\deleteWatermarkRequest $request)
    {
        try {
            list($response) = $this->deleteWatermarkWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteWatermarkWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteWatermarkWithHttpInfo
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteWatermarkWithHttpInfo(Requests\deleteWatermarkRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteWatermarkAsync
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWatermarkAsync(Requests\deleteWatermarkRequest $request) 
    {
        return $this->deleteWatermarkAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteWatermarkAsyncWithHttpInfo
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteWatermarkAsyncWithHttpInfo(Requests\deleteWatermarkRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation deleteWatermarkOnline
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return DeleteWatermarkOnlineResponse
     */
    public function deleteWatermarkOnline(Requests\deleteWatermarkOnlineRequest $request)
    {
        try {
            list($response) = $this->deleteWatermarkOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->deleteWatermarkOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation deleteWatermarkOnlineWithHttpInfo
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of DeleteWatermarkOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function deleteWatermarkOnlineWithHttpInfo(Requests\deleteWatermarkOnlineRequest $request)
    {
        $returnType = 'DeleteWatermarkOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'DeleteWatermarkOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation deleteWatermarkOnlineAsync
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWatermarkOnlineAsync(Requests\deleteWatermarkOnlineRequest $request) 
    {
        return $this->deleteWatermarkOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation deleteWatermarkOnlineAsyncWithHttpInfo
     *
     * Removes a watermark from the document.
     *
     * @param Requests\deleteWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function deleteWatermarkOnlineAsyncWithHttpInfo(Requests\deleteWatermarkOnlineRequest $request) 
    {
        $returnType = 'DeleteWatermarkOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation downloadFile
     *
     * Download file.
     *
     * @param Requests\downloadFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function downloadFile(Requests\downloadFileRequest $request)
    {
        try {
            list($response) = $this->downloadFileWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->downloadFileWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation downloadFileWithHttpInfo
     *
     * Download file.
     *
     * @param Requests\downloadFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function downloadFileWithHttpInfo(Requests\downloadFileRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation downloadFileAsync
     *
     * Download file.
     *
     * @param Requests\downloadFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileAsync(Requests\downloadFileRequest $request) 
    {
        return $this->downloadFileAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation downloadFileAsyncWithHttpInfo
     *
     * Download file.
     *
     * @param Requests\downloadFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function downloadFileAsyncWithHttpInfo(Requests\downloadFileRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation executeMailMerge
     *
     * Executes a Mail Merge operation.
     *
     * @param Requests\executeMailMergeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function executeMailMerge(Requests\executeMailMergeRequest $request)
    {
        try {
            list($response) = $this->executeMailMergeWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->executeMailMergeWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation executeMailMergeWithHttpInfo
     *
     * Executes a Mail Merge operation.
     *
     * @param Requests\executeMailMergeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function executeMailMergeWithHttpInfo(Requests\executeMailMergeRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation executeMailMergeAsync
     *
     * Executes a Mail Merge operation.
     *
     * @param Requests\executeMailMergeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeMailMergeAsync(Requests\executeMailMergeRequest $request) 
    {
        return $this->executeMailMergeAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation executeMailMergeAsyncWithHttpInfo
     *
     * Executes a Mail Merge operation.
     *
     * @param Requests\executeMailMergeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function executeMailMergeAsyncWithHttpInfo(Requests\executeMailMergeRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation executeMailMergeOnline
     *
     * Executes a Mail Merge operation online.
     *
     * @param Requests\executeMailMergeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function executeMailMergeOnline(Requests\executeMailMergeOnlineRequest $request)
    {
        try {
            list($response) = $this->executeMailMergeOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->executeMailMergeOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation executeMailMergeOnlineWithHttpInfo
     *
     * Executes a Mail Merge operation online.
     *
     * @param Requests\executeMailMergeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function executeMailMergeOnlineWithHttpInfo(Requests\executeMailMergeOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation executeMailMergeOnlineAsync
     *
     * Executes a Mail Merge operation online.
     *
     * @param Requests\executeMailMergeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function executeMailMergeOnlineAsync(Requests\executeMailMergeOnlineRequest $request) 
    {
        return $this->executeMailMergeOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation executeMailMergeOnlineAsyncWithHttpInfo
     *
     * Executes a Mail Merge operation online.
     *
     * @param Requests\executeMailMergeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function executeMailMergeOnlineAsyncWithHttpInfo(Requests\executeMailMergeOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getAllRevisions
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RevisionsResponse
     */
    public function getAllRevisions(Requests\getAllRevisionsRequest $request)
    {
        try {
            list($response) = $this->getAllRevisionsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getAllRevisionsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getAllRevisionsWithHttpInfo
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RevisionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getAllRevisionsWithHttpInfo(Requests\getAllRevisionsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RevisionsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RevisionsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getAllRevisionsAsync
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllRevisionsAsync(Requests\getAllRevisionsRequest $request) 
    {
        return $this->getAllRevisionsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getAllRevisionsAsyncWithHttpInfo
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getAllRevisionsAsyncWithHttpInfo(Requests\getAllRevisionsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RevisionsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getAllRevisionsOnline
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RevisionsResponse
     */
    public function getAllRevisionsOnline(Requests\getAllRevisionsOnlineRequest $request)
    {
        try {
            list($response) = $this->getAllRevisionsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getAllRevisionsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getAllRevisionsOnlineWithHttpInfo
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RevisionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getAllRevisionsOnlineWithHttpInfo(Requests\getAllRevisionsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RevisionsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RevisionsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getAllRevisionsOnlineAsync
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllRevisionsOnlineAsync(Requests\getAllRevisionsOnlineRequest $request) 
    {
        return $this->getAllRevisionsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getAllRevisionsOnlineAsyncWithHttpInfo
     *
     * Get all information about revisions.
     *
     * @param Requests\getAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getAllRevisionsOnlineAsyncWithHttpInfo(Requests\getAllRevisionsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RevisionsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getAvailableFonts
     *
     * Reads available fonts from the document.
     *
     * @param Requests\getAvailableFontsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\AvailableFontsResponse
     */
    public function getAvailableFonts(Requests\getAvailableFontsRequest $request)
    {
        try {
            list($response) = $this->getAvailableFontsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getAvailableFontsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getAvailableFontsWithHttpInfo
     *
     * Reads available fonts from the document.
     *
     * @param Requests\getAvailableFontsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\AvailableFontsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getAvailableFontsWithHttpInfo(Requests\getAvailableFontsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\AvailableFontsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\AvailableFontsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getAvailableFontsAsync
     *
     * Reads available fonts from the document.
     *
     * @param Requests\getAvailableFontsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAvailableFontsAsync(Requests\getAvailableFontsRequest $request) 
    {
        return $this->getAvailableFontsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getAvailableFontsAsyncWithHttpInfo
     *
     * Reads available fonts from the document.
     *
     * @param Requests\getAvailableFontsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getAvailableFontsAsyncWithHttpInfo(Requests\getAvailableFontsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\AvailableFontsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBookmarkByName
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarkResponse
     */
    public function getBookmarkByName(Requests\getBookmarkByNameRequest $request)
    {
        try {
            list($response) = $this->getBookmarkByNameWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBookmarkByNameWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBookmarkByNameWithHttpInfo
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBookmarkByNameWithHttpInfo(Requests\getBookmarkByNameRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBookmarkByNameAsync
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBookmarkByNameAsync(Requests\getBookmarkByNameRequest $request) 
    {
        return $this->getBookmarkByNameAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBookmarkByNameAsyncWithHttpInfo
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBookmarkByNameAsyncWithHttpInfo(Requests\getBookmarkByNameRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBookmarkByNameOnline
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarkResponse
     */
    public function getBookmarkByNameOnline(Requests\getBookmarkByNameOnlineRequest $request)
    {
        try {
            list($response) = $this->getBookmarkByNameOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBookmarkByNameOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBookmarkByNameOnlineWithHttpInfo
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBookmarkByNameOnlineWithHttpInfo(Requests\getBookmarkByNameOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBookmarkByNameOnlineAsync
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBookmarkByNameOnlineAsync(Requests\getBookmarkByNameOnlineRequest $request) 
    {
        return $this->getBookmarkByNameOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBookmarkByNameOnlineAsyncWithHttpInfo
     *
     * Reads a bookmark, specified by name, from the document.
     *
     * @param Requests\getBookmarkByNameOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBookmarkByNameOnlineAsyncWithHttpInfo(Requests\getBookmarkByNameOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBookmarks
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarksResponse
     */
    public function getBookmarks(Requests\getBookmarksRequest $request)
    {
        try {
            list($response) = $this->getBookmarksWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBookmarksWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBookmarksWithHttpInfo
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBookmarksWithHttpInfo(Requests\getBookmarksRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarksResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarksResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBookmarksAsync
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBookmarksAsync(Requests\getBookmarksRequest $request) 
    {
        return $this->getBookmarksAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBookmarksAsyncWithHttpInfo
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBookmarksAsyncWithHttpInfo(Requests\getBookmarksRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarksResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBookmarksOnline
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarksResponse
     */
    public function getBookmarksOnline(Requests\getBookmarksOnlineRequest $request)
    {
        try {
            list($response) = $this->getBookmarksOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBookmarksOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBookmarksOnlineWithHttpInfo
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBookmarksOnlineWithHttpInfo(Requests\getBookmarksOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarksResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarksResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBookmarksOnlineAsync
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBookmarksOnlineAsync(Requests\getBookmarksOnlineRequest $request) 
    {
        return $this->getBookmarksOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBookmarksOnlineAsyncWithHttpInfo
     *
     * Reads bookmarks from the document.
     *
     * @param Requests\getBookmarksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBookmarksOnlineAsyncWithHttpInfo(Requests\getBookmarksOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarksResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBorder
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BorderResponse
     */
    public function getBorder(Requests\getBorderRequest $request)
    {
        try {
            list($response) = $this->getBorderWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBorderWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBorderWithHttpInfo
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BorderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBorderWithHttpInfo(Requests\getBorderRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BorderResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBorderAsync
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBorderAsync(Requests\getBorderRequest $request) 
    {
        return $this->getBorderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBorderAsyncWithHttpInfo
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBorderAsyncWithHttpInfo(Requests\getBorderRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBorderOnline
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BorderResponse
     */
    public function getBorderOnline(Requests\getBorderOnlineRequest $request)
    {
        try {
            list($response) = $this->getBorderOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBorderOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBorderOnlineWithHttpInfo
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BorderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBorderOnlineWithHttpInfo(Requests\getBorderOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BorderResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBorderOnlineAsync
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBorderOnlineAsync(Requests\getBorderOnlineRequest $request) 
    {
        return $this->getBorderOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBorderOnlineAsyncWithHttpInfo
     *
     * Reads a border from the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\getBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBorderOnlineAsyncWithHttpInfo(Requests\getBorderOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBorders
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BordersResponse
     */
    public function getBorders(Requests\getBordersRequest $request)
    {
        try {
            list($response) = $this->getBordersWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBordersWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBordersWithHttpInfo
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BordersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBordersWithHttpInfo(Requests\getBordersRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BordersResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBordersAsync
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBordersAsync(Requests\getBordersRequest $request) 
    {
        return $this->getBordersAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBordersAsyncWithHttpInfo
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBordersAsyncWithHttpInfo(Requests\getBordersRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getBordersOnline
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BordersResponse
     */
    public function getBordersOnline(Requests\getBordersOnlineRequest $request)
    {
        try {
            list($response) = $this->getBordersOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getBordersOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getBordersOnlineWithHttpInfo
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BordersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getBordersOnlineWithHttpInfo(Requests\getBordersOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BordersResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getBordersOnlineAsync
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBordersOnlineAsync(Requests\getBordersOnlineRequest $request) 
    {
        return $this->getBordersOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getBordersOnlineAsyncWithHttpInfo
     *
     * Reads borders from the document node.
     *
     * @param Requests\getBordersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getBordersOnlineAsyncWithHttpInfo(Requests\getBordersOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BordersResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getComment
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentResponse
     */
    public function getComment(Requests\getCommentRequest $request)
    {
        try {
            list($response) = $this->getCommentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCommentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCommentWithHttpInfo
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCommentWithHttpInfo(Requests\getCommentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCommentAsync
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentAsync(Requests\getCommentRequest $request) 
    {
        return $this->getCommentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCommentAsyncWithHttpInfo
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCommentAsyncWithHttpInfo(Requests\getCommentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCommentOnline
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentResponse
     */
    public function getCommentOnline(Requests\getCommentOnlineRequest $request)
    {
        try {
            list($response) = $this->getCommentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCommentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCommentOnlineWithHttpInfo
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCommentOnlineWithHttpInfo(Requests\getCommentOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCommentOnlineAsync
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentOnlineAsync(Requests\getCommentOnlineRequest $request) 
    {
        return $this->getCommentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCommentOnlineAsyncWithHttpInfo
     *
     * Reads a comment from the document.
     *
     * @param Requests\getCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCommentOnlineAsyncWithHttpInfo(Requests\getCommentOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getComments
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentsResponse
     */
    public function getComments(Requests\getCommentsRequest $request)
    {
        try {
            list($response) = $this->getCommentsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCommentsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCommentsWithHttpInfo
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCommentsWithHttpInfo(Requests\getCommentsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCommentsAsync
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsAsync(Requests\getCommentsRequest $request) 
    {
        return $this->getCommentsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCommentsAsyncWithHttpInfo
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCommentsAsyncWithHttpInfo(Requests\getCommentsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCommentsOnline
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentsResponse
     */
    public function getCommentsOnline(Requests\getCommentsOnlineRequest $request)
    {
        try {
            list($response) = $this->getCommentsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCommentsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCommentsOnlineWithHttpInfo
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCommentsOnlineWithHttpInfo(Requests\getCommentsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCommentsOnlineAsync
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommentsOnlineAsync(Requests\getCommentsOnlineRequest $request) 
    {
        return $this->getCommentsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCommentsOnlineAsyncWithHttpInfo
     *
     * Reads comments from the document.
     *
     * @param Requests\getCommentsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCommentsOnlineAsyncWithHttpInfo(Requests\getCommentsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCustomXmlPart
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartResponse
     */
    public function getCustomXmlPart(Requests\getCustomXmlPartRequest $request)
    {
        try {
            list($response) = $this->getCustomXmlPartWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCustomXmlPartWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCustomXmlPartWithHttpInfo
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCustomXmlPartWithHttpInfo(Requests\getCustomXmlPartRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCustomXmlPartAsync
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomXmlPartAsync(Requests\getCustomXmlPartRequest $request) 
    {
        return $this->getCustomXmlPartAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCustomXmlPartAsyncWithHttpInfo
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCustomXmlPartAsyncWithHttpInfo(Requests\getCustomXmlPartRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCustomXmlPartOnline
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartResponse
     */
    public function getCustomXmlPartOnline(Requests\getCustomXmlPartOnlineRequest $request)
    {
        try {
            list($response) = $this->getCustomXmlPartOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCustomXmlPartOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCustomXmlPartOnlineWithHttpInfo
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCustomXmlPartOnlineWithHttpInfo(Requests\getCustomXmlPartOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCustomXmlPartOnlineAsync
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomXmlPartOnlineAsync(Requests\getCustomXmlPartOnlineRequest $request) 
    {
        return $this->getCustomXmlPartOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCustomXmlPartOnlineAsyncWithHttpInfo
     *
     * Reads the custom xml part from the document.
     *
     * @param Requests\getCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCustomXmlPartOnlineAsyncWithHttpInfo(Requests\getCustomXmlPartOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCustomXmlParts
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartsResponse
     */
    public function getCustomXmlParts(Requests\getCustomXmlPartsRequest $request)
    {
        try {
            list($response) = $this->getCustomXmlPartsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCustomXmlPartsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCustomXmlPartsWithHttpInfo
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCustomXmlPartsWithHttpInfo(Requests\getCustomXmlPartsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCustomXmlPartsAsync
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomXmlPartsAsync(Requests\getCustomXmlPartsRequest $request) 
    {
        return $this->getCustomXmlPartsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCustomXmlPartsAsyncWithHttpInfo
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCustomXmlPartsAsyncWithHttpInfo(Requests\getCustomXmlPartsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getCustomXmlPartsOnline
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartsResponse
     */
    public function getCustomXmlPartsOnline(Requests\getCustomXmlPartsOnlineRequest $request)
    {
        try {
            list($response) = $this->getCustomXmlPartsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getCustomXmlPartsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getCustomXmlPartsOnlineWithHttpInfo
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getCustomXmlPartsOnlineWithHttpInfo(Requests\getCustomXmlPartsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getCustomXmlPartsOnlineAsync
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomXmlPartsOnlineAsync(Requests\getCustomXmlPartsOnlineRequest $request) 
    {
        return $this->getCustomXmlPartsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getCustomXmlPartsOnlineAsyncWithHttpInfo
     *
     * Reads custom xml parts from the document.
     *
     * @param Requests\getCustomXmlPartsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getCustomXmlPartsOnlineAsyncWithHttpInfo(Requests\getCustomXmlPartsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocument
     *
     * Reads common information from the document.
     *
     * @param Requests\getDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function getDocument(Requests\getDocumentRequest $request)
    {
        try {
            list($response) = $this->getDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentWithHttpInfo
     *
     * Reads common information from the document.
     *
     * @param Requests\getDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentWithHttpInfo(Requests\getDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentAsync
     *
     * Reads common information from the document.
     *
     * @param Requests\getDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentAsync(Requests\getDocumentRequest $request) 
    {
        return $this->getDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentAsyncWithHttpInfo
     *
     * Reads common information from the document.
     *
     * @param Requests\getDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentAsyncWithHttpInfo(Requests\getDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectByIndex
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectResponse
     */
    public function getDocumentDrawingObjectByIndex(Requests\getDocumentDrawingObjectByIndexRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectByIndexWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectByIndexWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectByIndexWithHttpInfo
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectByIndexWithHttpInfo(Requests\getDocumentDrawingObjectByIndexRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectByIndexAsync
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectByIndexAsync(Requests\getDocumentDrawingObjectByIndexRequest $request) 
    {
        return $this->getDocumentDrawingObjectByIndexAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectByIndexAsyncWithHttpInfo
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectByIndexAsyncWithHttpInfo(Requests\getDocumentDrawingObjectByIndexRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectByIndexOnline
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectResponse
     */
    public function getDocumentDrawingObjectByIndexOnline(Requests\getDocumentDrawingObjectByIndexOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectByIndexOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectByIndexOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectByIndexOnlineWithHttpInfo
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectByIndexOnlineWithHttpInfo(Requests\getDocumentDrawingObjectByIndexOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectByIndexOnlineAsync
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectByIndexOnlineAsync(Requests\getDocumentDrawingObjectByIndexOnlineRequest $request) 
    {
        return $this->getDocumentDrawingObjectByIndexOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectByIndexOnlineAsyncWithHttpInfo
     *
     * Reads a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectByIndexOnlineAsyncWithHttpInfo(Requests\getDocumentDrawingObjectByIndexOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectImageData
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentDrawingObjectImageData(Requests\getDocumentDrawingObjectImageDataRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectImageDataWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectImageDataWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectImageDataWithHttpInfo
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectImageDataWithHttpInfo(Requests\getDocumentDrawingObjectImageDataRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectImageDataAsync
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectImageDataAsync(Requests\getDocumentDrawingObjectImageDataRequest $request) 
    {
        return $this->getDocumentDrawingObjectImageDataAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectImageDataAsyncWithHttpInfo
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectImageDataAsyncWithHttpInfo(Requests\getDocumentDrawingObjectImageDataRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectImageDataOnline
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentDrawingObjectImageDataOnline(Requests\getDocumentDrawingObjectImageDataOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectImageDataOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectImageDataOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectImageDataOnlineWithHttpInfo
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectImageDataOnlineWithHttpInfo(Requests\getDocumentDrawingObjectImageDataOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectImageDataOnlineAsync
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectImageDataOnlineAsync(Requests\getDocumentDrawingObjectImageDataOnlineRequest $request) 
    {
        return $this->getDocumentDrawingObjectImageDataOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectImageDataOnlineAsyncWithHttpInfo
     *
     * Reads image data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectImageDataOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectImageDataOnlineAsyncWithHttpInfo(Requests\getDocumentDrawingObjectImageDataOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectOleData
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentDrawingObjectOleData(Requests\getDocumentDrawingObjectOleDataRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectOleDataWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectOleDataWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectOleDataWithHttpInfo
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectOleDataWithHttpInfo(Requests\getDocumentDrawingObjectOleDataRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectOleDataAsync
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectOleDataAsync(Requests\getDocumentDrawingObjectOleDataRequest $request) 
    {
        return $this->getDocumentDrawingObjectOleDataAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectOleDataAsyncWithHttpInfo
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectOleDataAsyncWithHttpInfo(Requests\getDocumentDrawingObjectOleDataRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectOleDataOnline
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentDrawingObjectOleDataOnline(Requests\getDocumentDrawingObjectOleDataOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectOleDataOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectOleDataOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectOleDataOnlineWithHttpInfo
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectOleDataOnlineWithHttpInfo(Requests\getDocumentDrawingObjectOleDataOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectOleDataOnlineAsync
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectOleDataOnlineAsync(Requests\getDocumentDrawingObjectOleDataOnlineRequest $request) 
    {
        return $this->getDocumentDrawingObjectOleDataOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectOleDataOnlineAsyncWithHttpInfo
     *
     * Reads OLE data of a DrawingObject from the document node.
     *
     * @param Requests\getDocumentDrawingObjectOleDataOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectOleDataOnlineAsyncWithHttpInfo(Requests\getDocumentDrawingObjectOleDataOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjects
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectsResponse
     */
    public function getDocumentDrawingObjects(Requests\getDocumentDrawingObjectsRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectsWithHttpInfo
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectsWithHttpInfo(Requests\getDocumentDrawingObjectsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectsAsync
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectsAsync(Requests\getDocumentDrawingObjectsRequest $request) 
    {
        return $this->getDocumentDrawingObjectsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectsAsyncWithHttpInfo
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectsAsyncWithHttpInfo(Requests\getDocumentDrawingObjectsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectsOnline
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectsResponse
     */
    public function getDocumentDrawingObjectsOnline(Requests\getDocumentDrawingObjectsOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentDrawingObjectsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentDrawingObjectsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentDrawingObjectsOnlineWithHttpInfo
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentDrawingObjectsOnlineWithHttpInfo(Requests\getDocumentDrawingObjectsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentDrawingObjectsOnlineAsync
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentDrawingObjectsOnlineAsync(Requests\getDocumentDrawingObjectsOnlineRequest $request) 
    {
        return $this->getDocumentDrawingObjectsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentDrawingObjectsOnlineAsyncWithHttpInfo
     *
     * Reads DrawingObjects from the document node.
     *
     * @param Requests\getDocumentDrawingObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentDrawingObjectsOnlineAsyncWithHttpInfo(Requests\getDocumentDrawingObjectsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentFieldNames
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldNamesResponse
     */
    public function getDocumentFieldNames(Requests\getDocumentFieldNamesRequest $request)
    {
        try {
            list($response) = $this->getDocumentFieldNamesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentFieldNamesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentFieldNamesWithHttpInfo
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldNamesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentFieldNamesWithHttpInfo(Requests\getDocumentFieldNamesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldNamesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldNamesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentFieldNamesAsync
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFieldNamesAsync(Requests\getDocumentFieldNamesRequest $request) 
    {
        return $this->getDocumentFieldNamesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentFieldNamesAsyncWithHttpInfo
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentFieldNamesAsyncWithHttpInfo(Requests\getDocumentFieldNamesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldNamesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentFieldNamesOnline
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldNamesResponse
     */
    public function getDocumentFieldNamesOnline(Requests\getDocumentFieldNamesOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentFieldNamesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentFieldNamesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentFieldNamesOnlineWithHttpInfo
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldNamesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentFieldNamesOnlineWithHttpInfo(Requests\getDocumentFieldNamesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldNamesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldNamesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentFieldNamesOnlineAsync
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentFieldNamesOnlineAsync(Requests\getDocumentFieldNamesOnlineRequest $request) 
    {
        return $this->getDocumentFieldNamesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentFieldNamesOnlineAsyncWithHttpInfo
     *
     * Reads merge field names from the document.
     *
     * @param Requests\getDocumentFieldNamesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentFieldNamesOnlineAsyncWithHttpInfo(Requests\getDocumentFieldNamesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldNamesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentHyperlinkByIndex
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HyperlinkResponse
     */
    public function getDocumentHyperlinkByIndex(Requests\getDocumentHyperlinkByIndexRequest $request)
    {
        try {
            list($response) = $this->getDocumentHyperlinkByIndexWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentHyperlinkByIndexWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentHyperlinkByIndexWithHttpInfo
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HyperlinkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentHyperlinkByIndexWithHttpInfo(Requests\getDocumentHyperlinkByIndexRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HyperlinkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HyperlinkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentHyperlinkByIndexAsync
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHyperlinkByIndexAsync(Requests\getDocumentHyperlinkByIndexRequest $request) 
    {
        return $this->getDocumentHyperlinkByIndexAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentHyperlinkByIndexAsyncWithHttpInfo
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentHyperlinkByIndexAsyncWithHttpInfo(Requests\getDocumentHyperlinkByIndexRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HyperlinkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentHyperlinkByIndexOnline
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HyperlinkResponse
     */
    public function getDocumentHyperlinkByIndexOnline(Requests\getDocumentHyperlinkByIndexOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentHyperlinkByIndexOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentHyperlinkByIndexOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentHyperlinkByIndexOnlineWithHttpInfo
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HyperlinkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentHyperlinkByIndexOnlineWithHttpInfo(Requests\getDocumentHyperlinkByIndexOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HyperlinkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HyperlinkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentHyperlinkByIndexOnlineAsync
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHyperlinkByIndexOnlineAsync(Requests\getDocumentHyperlinkByIndexOnlineRequest $request) 
    {
        return $this->getDocumentHyperlinkByIndexOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentHyperlinkByIndexOnlineAsyncWithHttpInfo
     *
     * Reads a hyperlink from the document.
     *
     * @param Requests\getDocumentHyperlinkByIndexOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentHyperlinkByIndexOnlineAsyncWithHttpInfo(Requests\getDocumentHyperlinkByIndexOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HyperlinkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentHyperlinks
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HyperlinksResponse
     */
    public function getDocumentHyperlinks(Requests\getDocumentHyperlinksRequest $request)
    {
        try {
            list($response) = $this->getDocumentHyperlinksWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentHyperlinksWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentHyperlinksWithHttpInfo
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HyperlinksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentHyperlinksWithHttpInfo(Requests\getDocumentHyperlinksRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HyperlinksResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HyperlinksResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentHyperlinksAsync
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHyperlinksAsync(Requests\getDocumentHyperlinksRequest $request) 
    {
        return $this->getDocumentHyperlinksAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentHyperlinksAsyncWithHttpInfo
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentHyperlinksAsyncWithHttpInfo(Requests\getDocumentHyperlinksRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HyperlinksResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentHyperlinksOnline
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HyperlinksResponse
     */
    public function getDocumentHyperlinksOnline(Requests\getDocumentHyperlinksOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentHyperlinksOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentHyperlinksOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentHyperlinksOnlineWithHttpInfo
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HyperlinksResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentHyperlinksOnlineWithHttpInfo(Requests\getDocumentHyperlinksOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HyperlinksResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HyperlinksResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentHyperlinksOnlineAsync
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentHyperlinksOnlineAsync(Requests\getDocumentHyperlinksOnlineRequest $request) 
    {
        return $this->getDocumentHyperlinksOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentHyperlinksOnlineAsyncWithHttpInfo
     *
     * Reads hyperlinks from the document.
     *
     * @param Requests\getDocumentHyperlinksOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentHyperlinksOnlineAsyncWithHttpInfo(Requests\getDocumentHyperlinksOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HyperlinksResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentProperties
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentPropertiesResponse
     */
    public function getDocumentProperties(Requests\getDocumentPropertiesRequest $request)
    {
        try {
            list($response) = $this->getDocumentPropertiesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentPropertiesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentPropertiesWithHttpInfo
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentPropertiesWithHttpInfo(Requests\getDocumentPropertiesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertiesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentPropertiesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentPropertiesAsync
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesAsync(Requests\getDocumentPropertiesRequest $request) 
    {
        return $this->getDocumentPropertiesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentPropertiesAsyncWithHttpInfo
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentPropertiesAsyncWithHttpInfo(Requests\getDocumentPropertiesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertiesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentPropertiesOnline
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentPropertiesResponse
     */
    public function getDocumentPropertiesOnline(Requests\getDocumentPropertiesOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentPropertiesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentPropertiesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentPropertiesOnlineWithHttpInfo
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentPropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentPropertiesOnlineWithHttpInfo(Requests\getDocumentPropertiesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertiesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentPropertiesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentPropertiesOnlineAsync
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertiesOnlineAsync(Requests\getDocumentPropertiesOnlineRequest $request) 
    {
        return $this->getDocumentPropertiesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentPropertiesOnlineAsyncWithHttpInfo
     *
     * Reads document properties.
     *
     * @param Requests\getDocumentPropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentPropertiesOnlineAsyncWithHttpInfo(Requests\getDocumentPropertiesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertiesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentProperty
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentPropertyResponse
     */
    public function getDocumentProperty(Requests\getDocumentPropertyRequest $request)
    {
        try {
            list($response) = $this->getDocumentPropertyWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentPropertyWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentPropertyWithHttpInfo
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentPropertyWithHttpInfo(Requests\getDocumentPropertyRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentPropertyResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentPropertyAsync
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyAsync(Requests\getDocumentPropertyRequest $request) 
    {
        return $this->getDocumentPropertyAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentPropertyAsyncWithHttpInfo
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentPropertyAsyncWithHttpInfo(Requests\getDocumentPropertyRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentPropertyOnline
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentPropertyResponse
     */
    public function getDocumentPropertyOnline(Requests\getDocumentPropertyOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentPropertyOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentPropertyOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentPropertyOnlineWithHttpInfo
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentPropertyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentPropertyOnlineWithHttpInfo(Requests\getDocumentPropertyOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentPropertyResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentPropertyOnlineAsync
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentPropertyOnlineAsync(Requests\getDocumentPropertyOnlineRequest $request) 
    {
        return $this->getDocumentPropertyOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentPropertyOnlineAsyncWithHttpInfo
     *
     * Reads a document property.
     *
     * @param Requests\getDocumentPropertyOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentPropertyOnlineAsyncWithHttpInfo(Requests\getDocumentPropertyOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentPropertyResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentProtection
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ProtectionDataResponse
     */
    public function getDocumentProtection(Requests\getDocumentProtectionRequest $request)
    {
        try {
            list($response) = $this->getDocumentProtectionWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentProtectionWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentProtectionWithHttpInfo
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ProtectionDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentProtectionWithHttpInfo(Requests\getDocumentProtectionRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ProtectionDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentProtectionAsync
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentProtectionAsync(Requests\getDocumentProtectionRequest $request) 
    {
        return $this->getDocumentProtectionAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentProtectionAsyncWithHttpInfo
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentProtectionAsyncWithHttpInfo(Requests\getDocumentProtectionRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentProtectionOnline
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ProtectionDataResponse
     */
    public function getDocumentProtectionOnline(Requests\getDocumentProtectionOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentProtectionOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentProtectionOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentProtectionOnlineWithHttpInfo
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ProtectionDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentProtectionOnlineWithHttpInfo(Requests\getDocumentProtectionOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ProtectionDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentProtectionOnlineAsync
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentProtectionOnlineAsync(Requests\getDocumentProtectionOnlineRequest $request) 
    {
        return $this->getDocumentProtectionOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentProtectionOnlineAsyncWithHttpInfo
     *
     * Reads protection properties from the document.
     *
     * @param Requests\getDocumentProtectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentProtectionOnlineAsyncWithHttpInfo(Requests\getDocumentProtectionOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentStatistics
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StatDataResponse
     */
    public function getDocumentStatistics(Requests\getDocumentStatisticsRequest $request)
    {
        try {
            list($response) = $this->getDocumentStatisticsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentStatisticsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentStatisticsWithHttpInfo
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StatDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentStatisticsWithHttpInfo(Requests\getDocumentStatisticsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StatDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StatDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentStatisticsAsync
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStatisticsAsync(Requests\getDocumentStatisticsRequest $request) 
    {
        return $this->getDocumentStatisticsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentStatisticsAsyncWithHttpInfo
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentStatisticsAsyncWithHttpInfo(Requests\getDocumentStatisticsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StatDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentStatisticsOnline
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StatDataResponse
     */
    public function getDocumentStatisticsOnline(Requests\getDocumentStatisticsOnlineRequest $request)
    {
        try {
            list($response) = $this->getDocumentStatisticsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentStatisticsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentStatisticsOnlineWithHttpInfo
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StatDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentStatisticsOnlineWithHttpInfo(Requests\getDocumentStatisticsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StatDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StatDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentStatisticsOnlineAsync
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentStatisticsOnlineAsync(Requests\getDocumentStatisticsOnlineRequest $request) 
    {
        return $this->getDocumentStatisticsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentStatisticsOnlineAsyncWithHttpInfo
     *
     * Reads document statistics.
     *
     * @param Requests\getDocumentStatisticsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentStatisticsOnlineAsyncWithHttpInfo(Requests\getDocumentStatisticsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StatDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getDocumentWithFormat
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\getDocumentWithFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function getDocumentWithFormat(Requests\getDocumentWithFormatRequest $request)
    {
        try {
            list($response) = $this->getDocumentWithFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getDocumentWithFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getDocumentWithFormatWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\getDocumentWithFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function getDocumentWithFormatWithHttpInfo(Requests\getDocumentWithFormatRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getDocumentWithFormatAsync
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\getDocumentWithFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocumentWithFormatAsync(Requests\getDocumentWithFormatRequest $request) 
    {
        return $this->getDocumentWithFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getDocumentWithFormatAsyncWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\getDocumentWithFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getDocumentWithFormatAsyncWithHttpInfo(Requests\getDocumentWithFormatRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getField
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldResponse
     */
    public function getField(Requests\getFieldRequest $request)
    {
        try {
            list($response) = $this->getFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFieldWithHttpInfo
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFieldWithHttpInfo(Requests\getFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFieldAsync
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync(Requests\getFieldRequest $request) 
    {
        return $this->getFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFieldAsyncWithHttpInfo
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFieldAsyncWithHttpInfo(Requests\getFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFieldOnline
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldResponse
     */
    public function getFieldOnline(Requests\getFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->getFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFieldOnlineWithHttpInfo
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFieldOnlineWithHttpInfo(Requests\getFieldOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFieldOnlineAsync
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldOnlineAsync(Requests\getFieldOnlineRequest $request) 
    {
        return $this->getFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFieldOnlineAsyncWithHttpInfo
     *
     * Reads a field from the document node.
     *
     * @param Requests\getFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFieldOnlineAsyncWithHttpInfo(Requests\getFieldOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFields
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldsResponse
     */
    public function getFields(Requests\getFieldsRequest $request)
    {
        try {
            list($response) = $this->getFieldsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFieldsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFieldsWithHttpInfo
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFieldsWithHttpInfo(Requests\getFieldsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFieldsAsync
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync(Requests\getFieldsRequest $request) 
    {
        return $this->getFieldsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFieldsAsyncWithHttpInfo(Requests\getFieldsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFieldsOnline
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldsResponse
     */
    public function getFieldsOnline(Requests\getFieldsOnlineRequest $request)
    {
        try {
            list($response) = $this->getFieldsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFieldsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFieldsOnlineWithHttpInfo
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFieldsOnlineWithHttpInfo(Requests\getFieldsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFieldsOnlineAsync
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsOnlineAsync(Requests\getFieldsOnlineRequest $request) 
    {
        return $this->getFieldsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFieldsOnlineAsyncWithHttpInfo
     *
     * Reads fields from the document node.
     *
     * @param Requests\getFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFieldsOnlineAsyncWithHttpInfo(Requests\getFieldsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFilesList
     *
     * Get all files and folders within a folder.
     *
     * @param Requests\getFilesListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FilesList
     */
    public function getFilesList(Requests\getFilesListRequest $request)
    {
        try {
            list($response) = $this->getFilesListWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFilesListWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFilesListWithHttpInfo
     *
     * Get all files and folders within a folder.
     *
     * @param Requests\getFilesListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FilesList, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFilesListWithHttpInfo(Requests\getFilesListRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FilesList';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FilesList', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFilesListAsync
     *
     * Get all files and folders within a folder.
     *
     * @param Requests\getFilesListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListAsync(Requests\getFilesListRequest $request) 
    {
        return $this->getFilesListAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFilesListAsyncWithHttpInfo
     *
     * Get all files and folders within a folder.
     *
     * @param Requests\getFilesListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFilesListAsyncWithHttpInfo(Requests\getFilesListRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FilesList';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFootnote
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnoteResponse
     */
    public function getFootnote(Requests\getFootnoteRequest $request)
    {
        try {
            list($response) = $this->getFootnoteWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFootnoteWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFootnoteWithHttpInfo
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnoteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFootnoteWithHttpInfo(Requests\getFootnoteRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnoteResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFootnoteAsync
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFootnoteAsync(Requests\getFootnoteRequest $request) 
    {
        return $this->getFootnoteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFootnoteAsyncWithHttpInfo
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFootnoteAsyncWithHttpInfo(Requests\getFootnoteRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFootnoteOnline
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnoteResponse
     */
    public function getFootnoteOnline(Requests\getFootnoteOnlineRequest $request)
    {
        try {
            list($response) = $this->getFootnoteOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFootnoteOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFootnoteOnlineWithHttpInfo
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnoteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFootnoteOnlineWithHttpInfo(Requests\getFootnoteOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnoteResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFootnoteOnlineAsync
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFootnoteOnlineAsync(Requests\getFootnoteOnlineRequest $request) 
    {
        return $this->getFootnoteOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFootnoteOnlineAsyncWithHttpInfo
     *
     * Reads a footnote from the document node.
     *
     * @param Requests\getFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFootnoteOnlineAsyncWithHttpInfo(Requests\getFootnoteOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFootnotes
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnotesResponse
     */
    public function getFootnotes(Requests\getFootnotesRequest $request)
    {
        try {
            list($response) = $this->getFootnotesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFootnotesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFootnotesWithHttpInfo
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnotesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFootnotesWithHttpInfo(Requests\getFootnotesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnotesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnotesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFootnotesAsync
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFootnotesAsync(Requests\getFootnotesRequest $request) 
    {
        return $this->getFootnotesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFootnotesAsyncWithHttpInfo
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFootnotesAsyncWithHttpInfo(Requests\getFootnotesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnotesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFootnotesOnline
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnotesResponse
     */
    public function getFootnotesOnline(Requests\getFootnotesOnlineRequest $request)
    {
        try {
            list($response) = $this->getFootnotesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFootnotesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFootnotesOnlineWithHttpInfo
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnotesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFootnotesOnlineWithHttpInfo(Requests\getFootnotesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnotesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnotesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFootnotesOnlineAsync
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFootnotesOnlineAsync(Requests\getFootnotesOnlineRequest $request) 
    {
        return $this->getFootnotesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFootnotesOnlineAsyncWithHttpInfo
     *
     * Reads footnotes from the document node.
     *
     * @param Requests\getFootnotesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFootnotesOnlineAsyncWithHttpInfo(Requests\getFootnotesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnotesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFormField
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldResponse
     */
    public function getFormField(Requests\getFormFieldRequest $request)
    {
        try {
            list($response) = $this->getFormFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFormFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFormFieldWithHttpInfo
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFormFieldWithHttpInfo(Requests\getFormFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFormFieldAsync
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormFieldAsync(Requests\getFormFieldRequest $request) 
    {
        return $this->getFormFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFormFieldAsyncWithHttpInfo
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFormFieldAsyncWithHttpInfo(Requests\getFormFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFormFieldOnline
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldResponse
     */
    public function getFormFieldOnline(Requests\getFormFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->getFormFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFormFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFormFieldOnlineWithHttpInfo
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFormFieldOnlineWithHttpInfo(Requests\getFormFieldOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFormFieldOnlineAsync
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormFieldOnlineAsync(Requests\getFormFieldOnlineRequest $request) 
    {
        return $this->getFormFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFormFieldOnlineAsyncWithHttpInfo
     *
     * Reads a form field from the document node.
     *
     * @param Requests\getFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFormFieldOnlineAsyncWithHttpInfo(Requests\getFormFieldOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFormFields
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldsResponse
     */
    public function getFormFields(Requests\getFormFieldsRequest $request)
    {
        try {
            list($response) = $this->getFormFieldsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFormFieldsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFormFieldsWithHttpInfo
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFormFieldsWithHttpInfo(Requests\getFormFieldsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFormFieldsAsync
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormFieldsAsync(Requests\getFormFieldsRequest $request) 
    {
        return $this->getFormFieldsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFormFieldsAsyncWithHttpInfo
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFormFieldsAsyncWithHttpInfo(Requests\getFormFieldsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getFormFieldsOnline
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldsResponse
     */
    public function getFormFieldsOnline(Requests\getFormFieldsOnlineRequest $request)
    {
        try {
            list($response) = $this->getFormFieldsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getFormFieldsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getFormFieldsOnlineWithHttpInfo
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getFormFieldsOnlineWithHttpInfo(Requests\getFormFieldsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getFormFieldsOnlineAsync
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormFieldsOnlineAsync(Requests\getFormFieldsOnlineRequest $request) 
    {
        return $this->getFormFieldsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getFormFieldsOnlineAsyncWithHttpInfo
     *
     * Reads form fields from the document node.
     *
     * @param Requests\getFormFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getFormFieldsOnlineAsyncWithHttpInfo(Requests\getFormFieldsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFooter
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFooterResponse
     */
    public function getHeaderFooter(Requests\getHeaderFooterRequest $request)
    {
        try {
            list($response) = $this->getHeaderFooterWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFooterWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFooterWithHttpInfo
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFooterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFooterWithHttpInfo(Requests\getHeaderFooterRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFooterResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFooterAsync
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFooterAsync(Requests\getHeaderFooterRequest $request) 
    {
        return $this->getHeaderFooterAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFooterAsyncWithHttpInfo
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFooterAsyncWithHttpInfo(Requests\getHeaderFooterRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFooterOfSection
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFooterResponse
     */
    public function getHeaderFooterOfSection(Requests\getHeaderFooterOfSectionRequest $request)
    {
        try {
            list($response) = $this->getHeaderFooterOfSectionWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFooterOfSectionWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFooterOfSectionWithHttpInfo
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFooterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFooterOfSectionWithHttpInfo(Requests\getHeaderFooterOfSectionRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFooterResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFooterOfSectionAsync
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFooterOfSectionAsync(Requests\getHeaderFooterOfSectionRequest $request) 
    {
        return $this->getHeaderFooterOfSectionAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFooterOfSectionAsyncWithHttpInfo
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFooterOfSectionAsyncWithHttpInfo(Requests\getHeaderFooterOfSectionRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFooterOfSectionOnline
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFooterResponse
     */
    public function getHeaderFooterOfSectionOnline(Requests\getHeaderFooterOfSectionOnlineRequest $request)
    {
        try {
            list($response) = $this->getHeaderFooterOfSectionOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFooterOfSectionOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFooterOfSectionOnlineWithHttpInfo
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFooterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFooterOfSectionOnlineWithHttpInfo(Requests\getHeaderFooterOfSectionOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFooterResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFooterOfSectionOnlineAsync
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFooterOfSectionOnlineAsync(Requests\getHeaderFooterOfSectionOnlineRequest $request) 
    {
        return $this->getHeaderFooterOfSectionOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFooterOfSectionOnlineAsyncWithHttpInfo
     *
     * Reads a HeaderFooter object from the document section.
     *
     * @param Requests\getHeaderFooterOfSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFooterOfSectionOnlineAsyncWithHttpInfo(Requests\getHeaderFooterOfSectionOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFooterOnline
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFooterResponse
     */
    public function getHeaderFooterOnline(Requests\getHeaderFooterOnlineRequest $request)
    {
        try {
            list($response) = $this->getHeaderFooterOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFooterOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFooterOnlineWithHttpInfo
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFooterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFooterOnlineWithHttpInfo(Requests\getHeaderFooterOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFooterResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFooterOnlineAsync
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFooterOnlineAsync(Requests\getHeaderFooterOnlineRequest $request) 
    {
        return $this->getHeaderFooterOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFooterOnlineAsyncWithHttpInfo
     *
     * Reads a HeaderFooter object from the document.
     *
     * @param Requests\getHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFooterOnlineAsyncWithHttpInfo(Requests\getHeaderFooterOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFooters
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFootersResponse
     */
    public function getHeaderFooters(Requests\getHeaderFootersRequest $request)
    {
        try {
            list($response) = $this->getHeaderFootersWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFootersWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFootersWithHttpInfo
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFootersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFootersWithHttpInfo(Requests\getHeaderFootersRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFootersResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFootersResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFootersAsync
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFootersAsync(Requests\getHeaderFootersRequest $request) 
    {
        return $this->getHeaderFootersAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFootersAsyncWithHttpInfo
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFootersAsyncWithHttpInfo(Requests\getHeaderFootersRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFootersResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getHeaderFootersOnline
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFootersResponse
     */
    public function getHeaderFootersOnline(Requests\getHeaderFootersOnlineRequest $request)
    {
        try {
            list($response) = $this->getHeaderFootersOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getHeaderFootersOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getHeaderFootersOnlineWithHttpInfo
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFootersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getHeaderFootersOnlineWithHttpInfo(Requests\getHeaderFootersOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFootersResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFootersResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getHeaderFootersOnlineAsync
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHeaderFootersOnlineAsync(Requests\getHeaderFootersOnlineRequest $request) 
    {
        return $this->getHeaderFootersOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getHeaderFootersOnlineAsyncWithHttpInfo
     *
     * Reads HeaderFooter objects from the document section.
     *
     * @param Requests\getHeaderFootersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getHeaderFootersOnlineAsyncWithHttpInfo(Requests\getHeaderFootersOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFootersResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getInfo
     *
     * Returns application info.
     *
     * @param Requests\getInfoRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\InfoResponse
     */
    public function getInfo(Requests\getInfoRequest $request)
    {
        try {
            list($response) = $this->getInfoWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getInfoWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getInfoWithHttpInfo
     *
     * Returns application info.
     *
     * @param Requests\getInfoRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\InfoResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getInfoWithHttpInfo(Requests\getInfoRequest $request)
    {
        $returnType = '\Aspose\Words\Model\InfoResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\InfoResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getInfoAsync
     *
     * Returns application info.
     *
     * @param Requests\getInfoRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInfoAsync(Requests\getInfoRequest $request) 
    {
        return $this->getInfoAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getInfoAsyncWithHttpInfo
     *
     * Returns application info.
     *
     * @param Requests\getInfoRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getInfoAsyncWithHttpInfo(Requests\getInfoRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\InfoResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getList
     *
     * Reads a list from the document.
     *
     * @param Requests\getListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListResponse
     */
    public function getList(Requests\getListRequest $request)
    {
        try {
            list($response) = $this->getListWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getListWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getListWithHttpInfo
     *
     * Reads a list from the document.
     *
     * @param Requests\getListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getListWithHttpInfo(Requests\getListRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getListAsync
     *
     * Reads a list from the document.
     *
     * @param Requests\getListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListAsync(Requests\getListRequest $request) 
    {
        return $this->getListAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getListAsyncWithHttpInfo
     *
     * Reads a list from the document.
     *
     * @param Requests\getListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getListAsyncWithHttpInfo(Requests\getListRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getListOnline
     *
     * Reads a list from the document.
     *
     * @param Requests\getListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListResponse
     */
    public function getListOnline(Requests\getListOnlineRequest $request)
    {
        try {
            list($response) = $this->getListOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getListOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getListOnlineWithHttpInfo
     *
     * Reads a list from the document.
     *
     * @param Requests\getListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getListOnlineWithHttpInfo(Requests\getListOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getListOnlineAsync
     *
     * Reads a list from the document.
     *
     * @param Requests\getListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListOnlineAsync(Requests\getListOnlineRequest $request) 
    {
        return $this->getListOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getListOnlineAsyncWithHttpInfo
     *
     * Reads a list from the document.
     *
     * @param Requests\getListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getListOnlineAsyncWithHttpInfo(Requests\getListOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getLists
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListsResponse
     */
    public function getLists(Requests\getListsRequest $request)
    {
        try {
            list($response) = $this->getListsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getListsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getListsWithHttpInfo
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getListsWithHttpInfo(Requests\getListsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getListsAsync
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsAsync(Requests\getListsRequest $request) 
    {
        return $this->getListsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getListsAsyncWithHttpInfo
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getListsAsyncWithHttpInfo(Requests\getListsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getListsOnline
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListsResponse
     */
    public function getListsOnline(Requests\getListsOnlineRequest $request)
    {
        try {
            list($response) = $this->getListsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getListsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getListsOnlineWithHttpInfo
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getListsOnlineWithHttpInfo(Requests\getListsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getListsOnlineAsync
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListsOnlineAsync(Requests\getListsOnlineRequest $request) 
    {
        return $this->getListsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getListsOnlineAsyncWithHttpInfo
     *
     * Reads lists from the document.
     *
     * @param Requests\getListsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getListsOnlineAsyncWithHttpInfo(Requests\getListsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getOfficeMathObject
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\OfficeMathObjectResponse
     */
    public function getOfficeMathObject(Requests\getOfficeMathObjectRequest $request)
    {
        try {
            list($response) = $this->getOfficeMathObjectWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getOfficeMathObjectWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getOfficeMathObjectWithHttpInfo
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\OfficeMathObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getOfficeMathObjectWithHttpInfo(Requests\getOfficeMathObjectRequest $request)
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\OfficeMathObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getOfficeMathObjectAsync
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfficeMathObjectAsync(Requests\getOfficeMathObjectRequest $request) 
    {
        return $this->getOfficeMathObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getOfficeMathObjectAsyncWithHttpInfo
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getOfficeMathObjectAsyncWithHttpInfo(Requests\getOfficeMathObjectRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getOfficeMathObjectOnline
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\OfficeMathObjectResponse
     */
    public function getOfficeMathObjectOnline(Requests\getOfficeMathObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->getOfficeMathObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getOfficeMathObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getOfficeMathObjectOnlineWithHttpInfo
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\OfficeMathObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getOfficeMathObjectOnlineWithHttpInfo(Requests\getOfficeMathObjectOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\OfficeMathObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getOfficeMathObjectOnlineAsync
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfficeMathObjectOnlineAsync(Requests\getOfficeMathObjectOnlineRequest $request) 
    {
        return $this->getOfficeMathObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getOfficeMathObjectOnlineAsyncWithHttpInfo
     *
     * Reads an OfficeMath object from the document node.
     *
     * @param Requests\getOfficeMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getOfficeMathObjectOnlineAsyncWithHttpInfo(Requests\getOfficeMathObjectOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getOfficeMathObjects
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\OfficeMathObjectsResponse
     */
    public function getOfficeMathObjects(Requests\getOfficeMathObjectsRequest $request)
    {
        try {
            list($response) = $this->getOfficeMathObjectsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getOfficeMathObjectsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getOfficeMathObjectsWithHttpInfo
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\OfficeMathObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getOfficeMathObjectsWithHttpInfo(Requests\getOfficeMathObjectsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\OfficeMathObjectsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getOfficeMathObjectsAsync
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfficeMathObjectsAsync(Requests\getOfficeMathObjectsRequest $request) 
    {
        return $this->getOfficeMathObjectsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getOfficeMathObjectsAsyncWithHttpInfo
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getOfficeMathObjectsAsyncWithHttpInfo(Requests\getOfficeMathObjectsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getOfficeMathObjectsOnline
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\OfficeMathObjectsResponse
     */
    public function getOfficeMathObjectsOnline(Requests\getOfficeMathObjectsOnlineRequest $request)
    {
        try {
            list($response) = $this->getOfficeMathObjectsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getOfficeMathObjectsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getOfficeMathObjectsOnlineWithHttpInfo
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\OfficeMathObjectsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getOfficeMathObjectsOnlineWithHttpInfo(Requests\getOfficeMathObjectsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\OfficeMathObjectsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getOfficeMathObjectsOnlineAsync
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOfficeMathObjectsOnlineAsync(Requests\getOfficeMathObjectsOnlineRequest $request) 
    {
        return $this->getOfficeMathObjectsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getOfficeMathObjectsOnlineAsyncWithHttpInfo
     *
     * Reads OfficeMath objects from the document node.
     *
     * @param Requests\getOfficeMathObjectsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getOfficeMathObjectsOnlineAsyncWithHttpInfo(Requests\getOfficeMathObjectsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\OfficeMathObjectsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraph
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphResponse
     */
    public function getParagraph(Requests\getParagraphRequest $request)
    {
        try {
            list($response) = $this->getParagraphWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphWithHttpInfo
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphWithHttpInfo(Requests\getParagraphRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphAsync
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphAsync(Requests\getParagraphRequest $request) 
    {
        return $this->getParagraphAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphAsyncWithHttpInfo
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphAsyncWithHttpInfo(Requests\getParagraphRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphFormat
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphFormatResponse
     */
    public function getParagraphFormat(Requests\getParagraphFormatRequest $request)
    {
        try {
            list($response) = $this->getParagraphFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphFormatWithHttpInfo
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphFormatWithHttpInfo(Requests\getParagraphFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphFormatAsync
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphFormatAsync(Requests\getParagraphFormatRequest $request) 
    {
        return $this->getParagraphFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphFormatAsyncWithHttpInfo
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphFormatAsyncWithHttpInfo(Requests\getParagraphFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphFormatOnline
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphFormatResponse
     */
    public function getParagraphFormatOnline(Requests\getParagraphFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->getParagraphFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphFormatOnlineWithHttpInfo
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphFormatOnlineWithHttpInfo(Requests\getParagraphFormatOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphFormatOnlineAsync
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphFormatOnlineAsync(Requests\getParagraphFormatOnlineRequest $request) 
    {
        return $this->getParagraphFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphFormatOnlineAsyncWithHttpInfo
     *
     * Reads the formatting properties of a paragraph from the document node.
     *
     * @param Requests\getParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphFormatOnlineAsyncWithHttpInfo(Requests\getParagraphFormatOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphListFormat
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphListFormatResponse
     */
    public function getParagraphListFormat(Requests\getParagraphListFormatRequest $request)
    {
        try {
            list($response) = $this->getParagraphListFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphListFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphListFormatWithHttpInfo
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphListFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphListFormatWithHttpInfo(Requests\getParagraphListFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphListFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphListFormatAsync
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphListFormatAsync(Requests\getParagraphListFormatRequest $request) 
    {
        return $this->getParagraphListFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphListFormatAsyncWithHttpInfo
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphListFormatAsyncWithHttpInfo(Requests\getParagraphListFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphListFormatOnline
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphListFormatResponse
     */
    public function getParagraphListFormatOnline(Requests\getParagraphListFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->getParagraphListFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphListFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphListFormatOnlineWithHttpInfo
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphListFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphListFormatOnlineWithHttpInfo(Requests\getParagraphListFormatOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphListFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphListFormatOnlineAsync
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphListFormatOnlineAsync(Requests\getParagraphListFormatOnlineRequest $request) 
    {
        return $this->getParagraphListFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphListFormatOnlineAsyncWithHttpInfo
     *
     * Reads the formatting properties of a paragraph list from the document node.
     *
     * @param Requests\getParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphListFormatOnlineAsyncWithHttpInfo(Requests\getParagraphListFormatOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphOnline
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphResponse
     */
    public function getParagraphOnline(Requests\getParagraphOnlineRequest $request)
    {
        try {
            list($response) = $this->getParagraphOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphOnlineWithHttpInfo
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphOnlineWithHttpInfo(Requests\getParagraphOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphOnlineAsync
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphOnlineAsync(Requests\getParagraphOnlineRequest $request) 
    {
        return $this->getParagraphOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphOnlineAsyncWithHttpInfo
     *
     * Reads a paragraph from the document node.
     *
     * @param Requests\getParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphOnlineAsyncWithHttpInfo(Requests\getParagraphOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphs
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphLinkCollectionResponse
     */
    public function getParagraphs(Requests\getParagraphsRequest $request)
    {
        try {
            list($response) = $this->getParagraphsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphsWithHttpInfo
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphsWithHttpInfo(Requests\getParagraphsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphsAsync
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphsAsync(Requests\getParagraphsRequest $request) 
    {
        return $this->getParagraphsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphsAsyncWithHttpInfo
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphsAsyncWithHttpInfo(Requests\getParagraphsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphsOnline
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphLinkCollectionResponse
     */
    public function getParagraphsOnline(Requests\getParagraphsOnlineRequest $request)
    {
        try {
            list($response) = $this->getParagraphsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphsOnlineWithHttpInfo
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphsOnlineWithHttpInfo(Requests\getParagraphsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphsOnlineAsync
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphsOnlineAsync(Requests\getParagraphsOnlineRequest $request) 
    {
        return $this->getParagraphsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphsOnlineAsyncWithHttpInfo
     *
     * Reads paragraphs from the document node.
     *
     * @param Requests\getParagraphsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphsOnlineAsyncWithHttpInfo(Requests\getParagraphsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphTabStops
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TabStopsResponse
     */
    public function getParagraphTabStops(Requests\getParagraphTabStopsRequest $request)
    {
        try {
            list($response) = $this->getParagraphTabStopsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphTabStopsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphTabStopsWithHttpInfo
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TabStopsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphTabStopsWithHttpInfo(Requests\getParagraphTabStopsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TabStopsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphTabStopsAsync
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphTabStopsAsync(Requests\getParagraphTabStopsRequest $request) 
    {
        return $this->getParagraphTabStopsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphTabStopsAsyncWithHttpInfo
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphTabStopsAsyncWithHttpInfo(Requests\getParagraphTabStopsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getParagraphTabStopsOnline
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TabStopsResponse
     */
    public function getParagraphTabStopsOnline(Requests\getParagraphTabStopsOnlineRequest $request)
    {
        try {
            list($response) = $this->getParagraphTabStopsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getParagraphTabStopsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getParagraphTabStopsOnlineWithHttpInfo
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TabStopsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getParagraphTabStopsOnlineWithHttpInfo(Requests\getParagraphTabStopsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TabStopsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getParagraphTabStopsOnlineAsync
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getParagraphTabStopsOnlineAsync(Requests\getParagraphTabStopsOnlineRequest $request) 
    {
        return $this->getParagraphTabStopsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getParagraphTabStopsOnlineAsyncWithHttpInfo
     *
     * Reads paragraph tab stops from the document node.
     *
     * @param Requests\getParagraphTabStopsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getParagraphTabStopsOnlineAsyncWithHttpInfo(Requests\getParagraphTabStopsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getPublicKey
     *
     * Get assymetric public key.
     *
     * @param Requests\getPublicKeyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\PublicKeyResponse
     */
    public function getPublicKey(Requests\getPublicKeyRequest $request)
    {
        try {
            list($response) = $this->getPublicKeyWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getPublicKeyWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getPublicKeyWithHttpInfo
     *
     * Get assymetric public key.
     *
     * @param Requests\getPublicKeyRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\PublicKeyResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getPublicKeyWithHttpInfo(Requests\getPublicKeyRequest $request)
    {
        $returnType = '\Aspose\Words\Model\PublicKeyResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\PublicKeyResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getPublicKeyAsync
     *
     * Get assymetric public key.
     *
     * @param Requests\getPublicKeyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicKeyAsync(Requests\getPublicKeyRequest $request) 
    {
        return $this->getPublicKeyAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getPublicKeyAsyncWithHttpInfo
     *
     * Get assymetric public key.
     *
     * @param Requests\getPublicKeyRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getPublicKeyAsyncWithHttpInfo(Requests\getPublicKeyRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\PublicKeyResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRangeText
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RangeTextResponse
     */
    public function getRangeText(Requests\getRangeTextRequest $request)
    {
        try {
            list($response) = $this->getRangeTextWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRangeTextWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRangeTextWithHttpInfo
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RangeTextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRangeTextWithHttpInfo(Requests\getRangeTextRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RangeTextResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RangeTextResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRangeTextAsync
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRangeTextAsync(Requests\getRangeTextRequest $request) 
    {
        return $this->getRangeTextAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRangeTextAsyncWithHttpInfo
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRangeTextAsyncWithHttpInfo(Requests\getRangeTextRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RangeTextResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRangeTextOnline
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RangeTextResponse
     */
    public function getRangeTextOnline(Requests\getRangeTextOnlineRequest $request)
    {
        try {
            list($response) = $this->getRangeTextOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRangeTextOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRangeTextOnlineWithHttpInfo
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RangeTextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRangeTextOnlineWithHttpInfo(Requests\getRangeTextOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RangeTextResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RangeTextResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRangeTextOnlineAsync
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRangeTextOnlineAsync(Requests\getRangeTextOnlineRequest $request) 
    {
        return $this->getRangeTextOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRangeTextOnlineAsyncWithHttpInfo
     *
     * Reads range text from the document.
     *
     * @param Requests\getRangeTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRangeTextOnlineAsyncWithHttpInfo(Requests\getRangeTextOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RangeTextResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRun
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunResponse
     */
    public function getRun(Requests\getRunRequest $request)
    {
        try {
            list($response) = $this->getRunWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunWithHttpInfo
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunWithHttpInfo(Requests\getRunRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunAsync
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunAsync(Requests\getRunRequest $request) 
    {
        return $this->getRunAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunAsyncWithHttpInfo
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunAsyncWithHttpInfo(Requests\getRunRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRunFont
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FontResponse
     */
    public function getRunFont(Requests\getRunFontRequest $request)
    {
        try {
            list($response) = $this->getRunFontWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunFontWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunFontWithHttpInfo
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FontResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunFontWithHttpInfo(Requests\getRunFontRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FontResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunFontAsync
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunFontAsync(Requests\getRunFontRequest $request) 
    {
        return $this->getRunFontAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunFontAsyncWithHttpInfo
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunFontAsyncWithHttpInfo(Requests\getRunFontRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRunFontOnline
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FontResponse
     */
    public function getRunFontOnline(Requests\getRunFontOnlineRequest $request)
    {
        try {
            list($response) = $this->getRunFontOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunFontOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunFontOnlineWithHttpInfo
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FontResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunFontOnlineWithHttpInfo(Requests\getRunFontOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FontResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunFontOnlineAsync
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunFontOnlineAsync(Requests\getRunFontOnlineRequest $request) 
    {
        return $this->getRunFontOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunFontOnlineAsyncWithHttpInfo
     *
     * Reads the font properties of a Run object from the paragraph.
     *
     * @param Requests\getRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunFontOnlineAsyncWithHttpInfo(Requests\getRunFontOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRunOnline
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunResponse
     */
    public function getRunOnline(Requests\getRunOnlineRequest $request)
    {
        try {
            list($response) = $this->getRunOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunOnlineWithHttpInfo
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunOnlineWithHttpInfo(Requests\getRunOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunOnlineAsync
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunOnlineAsync(Requests\getRunOnlineRequest $request) 
    {
        return $this->getRunOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunOnlineAsyncWithHttpInfo
     *
     * Reads a Run object from the paragraph.
     *
     * @param Requests\getRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunOnlineAsyncWithHttpInfo(Requests\getRunOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRuns
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunsResponse
     */
    public function getRuns(Requests\getRunsRequest $request)
    {
        try {
            list($response) = $this->getRunsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunsWithHttpInfo
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunsWithHttpInfo(Requests\getRunsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunsAsync
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunsAsync(Requests\getRunsRequest $request) 
    {
        return $this->getRunsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunsAsyncWithHttpInfo
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunsAsyncWithHttpInfo(Requests\getRunsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getRunsOnline
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunsResponse
     */
    public function getRunsOnline(Requests\getRunsOnlineRequest $request)
    {
        try {
            list($response) = $this->getRunsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getRunsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getRunsOnlineWithHttpInfo
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getRunsOnlineWithHttpInfo(Requests\getRunsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getRunsOnlineAsync
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRunsOnlineAsync(Requests\getRunsOnlineRequest $request) 
    {
        return $this->getRunsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getRunsOnlineAsyncWithHttpInfo
     *
     * Reads Run objects from the paragraph.
     *
     * @param Requests\getRunsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getRunsOnlineAsyncWithHttpInfo(Requests\getRunsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSection
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionResponse
     */
    public function getSection(Requests\getSectionRequest $request)
    {
        try {
            list($response) = $this->getSectionWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionWithHttpInfo
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionWithHttpInfo(Requests\getSectionRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionAsync
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionAsync(Requests\getSectionRequest $request) 
    {
        return $this->getSectionAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionAsyncWithHttpInfo
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionAsyncWithHttpInfo(Requests\getSectionRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSectionOnline
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionResponse
     */
    public function getSectionOnline(Requests\getSectionOnlineRequest $request)
    {
        try {
            list($response) = $this->getSectionOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionOnlineWithHttpInfo
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionOnlineWithHttpInfo(Requests\getSectionOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionOnlineAsync
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionOnlineAsync(Requests\getSectionOnlineRequest $request) 
    {
        return $this->getSectionOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionOnlineAsyncWithHttpInfo
     *
     * Reads a section from the document.
     *
     * @param Requests\getSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionOnlineAsyncWithHttpInfo(Requests\getSectionOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSectionPageSetup
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionPageSetupResponse
     */
    public function getSectionPageSetup(Requests\getSectionPageSetupRequest $request)
    {
        try {
            list($response) = $this->getSectionPageSetupWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionPageSetupWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionPageSetupWithHttpInfo
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionPageSetupResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionPageSetupWithHttpInfo(Requests\getSectionPageSetupRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionPageSetupResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionPageSetupAsync
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionPageSetupAsync(Requests\getSectionPageSetupRequest $request) 
    {
        return $this->getSectionPageSetupAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionPageSetupAsyncWithHttpInfo
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionPageSetupAsyncWithHttpInfo(Requests\getSectionPageSetupRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSectionPageSetupOnline
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionPageSetupResponse
     */
    public function getSectionPageSetupOnline(Requests\getSectionPageSetupOnlineRequest $request)
    {
        try {
            list($response) = $this->getSectionPageSetupOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionPageSetupOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionPageSetupOnlineWithHttpInfo
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionPageSetupResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionPageSetupOnlineWithHttpInfo(Requests\getSectionPageSetupOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionPageSetupResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionPageSetupOnlineAsync
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionPageSetupOnlineAsync(Requests\getSectionPageSetupOnlineRequest $request) 
    {
        return $this->getSectionPageSetupOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionPageSetupOnlineAsyncWithHttpInfo
     *
     * Reads the page setup of a section from the document.
     *
     * @param Requests\getSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionPageSetupOnlineAsyncWithHttpInfo(Requests\getSectionPageSetupOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSections
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionLinkCollectionResponse
     */
    public function getSections(Requests\getSectionsRequest $request)
    {
        try {
            list($response) = $this->getSectionsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionsWithHttpInfo
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionsWithHttpInfo(Requests\getSectionsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionsAsync
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionsAsync(Requests\getSectionsRequest $request) 
    {
        return $this->getSectionsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionsAsyncWithHttpInfo
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionsAsyncWithHttpInfo(Requests\getSectionsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSectionsOnline
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionLinkCollectionResponse
     */
    public function getSectionsOnline(Requests\getSectionsOnlineRequest $request)
    {
        try {
            list($response) = $this->getSectionsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSectionsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSectionsOnlineWithHttpInfo
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSectionsOnlineWithHttpInfo(Requests\getSectionsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSectionsOnlineAsync
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSectionsOnlineAsync(Requests\getSectionsOnlineRequest $request) 
    {
        return $this->getSectionsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSectionsOnlineAsyncWithHttpInfo
     *
     * Reads sections from the document.
     *
     * @param Requests\getSectionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSectionsOnlineAsyncWithHttpInfo(Requests\getSectionsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSignatures
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SignatureCollectionResponse
     */
    public function getSignatures(Requests\getSignaturesRequest $request)
    {
        try {
            list($response) = $this->getSignaturesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSignaturesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSignaturesWithHttpInfo
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SignatureCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSignaturesWithHttpInfo(Requests\getSignaturesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SignatureCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSignaturesAsync
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignaturesAsync(Requests\getSignaturesRequest $request) 
    {
        return $this->getSignaturesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSignaturesAsyncWithHttpInfo
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSignaturesAsyncWithHttpInfo(Requests\getSignaturesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getSignaturesOnline
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SignatureCollectionResponse
     */
    public function getSignaturesOnline(Requests\getSignaturesOnlineRequest $request)
    {
        try {
            list($response) = $this->getSignaturesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getSignaturesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getSignaturesOnlineWithHttpInfo
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SignatureCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getSignaturesOnlineWithHttpInfo(Requests\getSignaturesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SignatureCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getSignaturesOnlineAsync
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignaturesOnlineAsync(Requests\getSignaturesOnlineRequest $request) 
    {
        return $this->getSignaturesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getSignaturesOnlineAsyncWithHttpInfo
     *
     * Gets signatures from the document.
     *
     * @param Requests\getSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getSignaturesOnlineAsyncWithHttpInfo(Requests\getSignaturesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStructuredDocumentTag
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagResponse
     */
    public function getStructuredDocumentTag(Requests\getStructuredDocumentTagRequest $request)
    {
        try {
            list($response) = $this->getStructuredDocumentTagWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStructuredDocumentTagWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStructuredDocumentTagWithHttpInfo
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStructuredDocumentTagWithHttpInfo(Requests\getStructuredDocumentTagRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStructuredDocumentTagAsync
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStructuredDocumentTagAsync(Requests\getStructuredDocumentTagRequest $request) 
    {
        return $this->getStructuredDocumentTagAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagAsyncWithHttpInfo
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStructuredDocumentTagAsyncWithHttpInfo(Requests\getStructuredDocumentTagRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagOnline
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagResponse
     */
    public function getStructuredDocumentTagOnline(Requests\getStructuredDocumentTagOnlineRequest $request)
    {
        try {
            list($response) = $this->getStructuredDocumentTagOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStructuredDocumentTagOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStructuredDocumentTagOnlineWithHttpInfo
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStructuredDocumentTagOnlineWithHttpInfo(Requests\getStructuredDocumentTagOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStructuredDocumentTagOnlineAsync
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStructuredDocumentTagOnlineAsync(Requests\getStructuredDocumentTagOnlineRequest $request) 
    {
        return $this->getStructuredDocumentTagOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagOnlineAsyncWithHttpInfo
     *
     * Reads a StructuredDocumentTag (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStructuredDocumentTagOnlineAsyncWithHttpInfo(Requests\getStructuredDocumentTagOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStructuredDocumentTags
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagsResponse
     */
    public function getStructuredDocumentTags(Requests\getStructuredDocumentTagsRequest $request)
    {
        try {
            list($response) = $this->getStructuredDocumentTagsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStructuredDocumentTagsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStructuredDocumentTagsWithHttpInfo
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStructuredDocumentTagsWithHttpInfo(Requests\getStructuredDocumentTagsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStructuredDocumentTagsAsync
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStructuredDocumentTagsAsync(Requests\getStructuredDocumentTagsRequest $request) 
    {
        return $this->getStructuredDocumentTagsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagsAsyncWithHttpInfo
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStructuredDocumentTagsAsyncWithHttpInfo(Requests\getStructuredDocumentTagsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagsOnline
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagsResponse
     */
    public function getStructuredDocumentTagsOnline(Requests\getStructuredDocumentTagsOnlineRequest $request)
    {
        try {
            list($response) = $this->getStructuredDocumentTagsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStructuredDocumentTagsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStructuredDocumentTagsOnlineWithHttpInfo
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStructuredDocumentTagsOnlineWithHttpInfo(Requests\getStructuredDocumentTagsOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStructuredDocumentTagsOnlineAsync
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStructuredDocumentTagsOnlineAsync(Requests\getStructuredDocumentTagsOnlineRequest $request) 
    {
        return $this->getStructuredDocumentTagsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStructuredDocumentTagsOnlineAsyncWithHttpInfo
     *
     * Reads StructuredDocumentTags (SDT) from the document node.
     *
     * @param Requests\getStructuredDocumentTagsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStructuredDocumentTagsOnlineAsyncWithHttpInfo(Requests\getStructuredDocumentTagsOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStyle
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function getStyle(Requests\getStyleRequest $request)
    {
        try {
            list($response) = $this->getStyleWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStyleWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStyleWithHttpInfo
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStyleWithHttpInfo(Requests\getStyleRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStyleAsync
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStyleAsync(Requests\getStyleRequest $request) 
    {
        return $this->getStyleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStyleAsyncWithHttpInfo
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStyleAsyncWithHttpInfo(Requests\getStyleRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStyleFromDocumentElement
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function getStyleFromDocumentElement(Requests\getStyleFromDocumentElementRequest $request)
    {
        try {
            list($response) = $this->getStyleFromDocumentElementWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStyleFromDocumentElementWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStyleFromDocumentElementWithHttpInfo
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStyleFromDocumentElementWithHttpInfo(Requests\getStyleFromDocumentElementRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStyleFromDocumentElementAsync
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStyleFromDocumentElementAsync(Requests\getStyleFromDocumentElementRequest $request) 
    {
        return $this->getStyleFromDocumentElementAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStyleFromDocumentElementAsyncWithHttpInfo
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStyleFromDocumentElementAsyncWithHttpInfo(Requests\getStyleFromDocumentElementRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStyleFromDocumentElementOnline
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function getStyleFromDocumentElementOnline(Requests\getStyleFromDocumentElementOnlineRequest $request)
    {
        try {
            list($response) = $this->getStyleFromDocumentElementOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStyleFromDocumentElementOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStyleFromDocumentElementOnlineWithHttpInfo
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStyleFromDocumentElementOnlineWithHttpInfo(Requests\getStyleFromDocumentElementOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStyleFromDocumentElementOnlineAsync
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStyleFromDocumentElementOnlineAsync(Requests\getStyleFromDocumentElementOnlineRequest $request) 
    {
        return $this->getStyleFromDocumentElementOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStyleFromDocumentElementOnlineAsyncWithHttpInfo
     *
     * Reads a style from the document node.
     *
     * @param Requests\getStyleFromDocumentElementOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStyleFromDocumentElementOnlineAsyncWithHttpInfo(Requests\getStyleFromDocumentElementOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStyleOnline
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function getStyleOnline(Requests\getStyleOnlineRequest $request)
    {
        try {
            list($response) = $this->getStyleOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStyleOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStyleOnlineWithHttpInfo
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStyleOnlineWithHttpInfo(Requests\getStyleOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStyleOnlineAsync
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStyleOnlineAsync(Requests\getStyleOnlineRequest $request) 
    {
        return $this->getStyleOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStyleOnlineAsyncWithHttpInfo
     *
     * Reads a style from the document.
     *
     * @param Requests\getStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStyleOnlineAsyncWithHttpInfo(Requests\getStyleOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStyles
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StylesResponse
     */
    public function getStyles(Requests\getStylesRequest $request)
    {
        try {
            list($response) = $this->getStylesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStylesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStylesWithHttpInfo
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StylesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStylesWithHttpInfo(Requests\getStylesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StylesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StylesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStylesAsync
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStylesAsync(Requests\getStylesRequest $request) 
    {
        return $this->getStylesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStylesAsyncWithHttpInfo
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStylesAsyncWithHttpInfo(Requests\getStylesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StylesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getStylesOnline
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StylesResponse
     */
    public function getStylesOnline(Requests\getStylesOnlineRequest $request)
    {
        try {
            list($response) = $this->getStylesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getStylesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getStylesOnlineWithHttpInfo
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StylesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getStylesOnlineWithHttpInfo(Requests\getStylesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StylesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StylesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getStylesOnlineAsync
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStylesOnlineAsync(Requests\getStylesOnlineRequest $request) 
    {
        return $this->getStylesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getStylesOnlineAsyncWithHttpInfo
     *
     * Reads styles from the document.
     *
     * @param Requests\getStylesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getStylesOnlineAsyncWithHttpInfo(Requests\getStylesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StylesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTable
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableResponse
     */
    public function getTable(Requests\getTableRequest $request)
    {
        try {
            list($response) = $this->getTableWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableWithHttpInfo
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableWithHttpInfo(Requests\getTableRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableAsync
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsync(Requests\getTableRequest $request) 
    {
        return $this->getTableAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableAsyncWithHttpInfo
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableAsyncWithHttpInfo(Requests\getTableRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableCell
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellResponse
     */
    public function getTableCell(Requests\getTableCellRequest $request)
    {
        try {
            list($response) = $this->getTableCellWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableCellWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableCellWithHttpInfo
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableCellWithHttpInfo(Requests\getTableCellRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableCellAsync
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableCellAsync(Requests\getTableCellRequest $request) 
    {
        return $this->getTableCellAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableCellAsyncWithHttpInfo
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableCellAsyncWithHttpInfo(Requests\getTableCellRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableCellFormat
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellFormatResponse
     */
    public function getTableCellFormat(Requests\getTableCellFormatRequest $request)
    {
        try {
            list($response) = $this->getTableCellFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableCellFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableCellFormatWithHttpInfo
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableCellFormatWithHttpInfo(Requests\getTableCellFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableCellFormatAsync
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableCellFormatAsync(Requests\getTableCellFormatRequest $request) 
    {
        return $this->getTableCellFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableCellFormatAsyncWithHttpInfo
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableCellFormatAsyncWithHttpInfo(Requests\getTableCellFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableCellFormatOnline
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellFormatResponse
     */
    public function getTableCellFormatOnline(Requests\getTableCellFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->getTableCellFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableCellFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableCellFormatOnlineWithHttpInfo
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableCellFormatOnlineWithHttpInfo(Requests\getTableCellFormatOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableCellFormatOnlineAsync
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableCellFormatOnlineAsync(Requests\getTableCellFormatOnlineRequest $request) 
    {
        return $this->getTableCellFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableCellFormatOnlineAsyncWithHttpInfo
     *
     * Reads the formatting properties of a table cell.
     *
     * @param Requests\getTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableCellFormatOnlineAsyncWithHttpInfo(Requests\getTableCellFormatOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableCellOnline
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellResponse
     */
    public function getTableCellOnline(Requests\getTableCellOnlineRequest $request)
    {
        try {
            list($response) = $this->getTableCellOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableCellOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableCellOnlineWithHttpInfo
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableCellOnlineWithHttpInfo(Requests\getTableCellOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableCellOnlineAsync
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableCellOnlineAsync(Requests\getTableCellOnlineRequest $request) 
    {
        return $this->getTableCellOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableCellOnlineAsyncWithHttpInfo
     *
     * Reads a cell from the table row.
     *
     * @param Requests\getTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableCellOnlineAsyncWithHttpInfo(Requests\getTableCellOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableOnline
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableResponse
     */
    public function getTableOnline(Requests\getTableOnlineRequest $request)
    {
        try {
            list($response) = $this->getTableOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableOnlineWithHttpInfo
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableOnlineWithHttpInfo(Requests\getTableOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableOnlineAsync
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableOnlineAsync(Requests\getTableOnlineRequest $request) 
    {
        return $this->getTableOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableOnlineAsyncWithHttpInfo
     *
     * Reads a table from the document node.
     *
     * @param Requests\getTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableOnlineAsyncWithHttpInfo(Requests\getTableOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableProperties
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TablePropertiesResponse
     */
    public function getTableProperties(Requests\getTablePropertiesRequest $request)
    {
        try {
            list($response) = $this->getTablePropertiesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTablePropertiesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTablePropertiesWithHttpInfo
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TablePropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTablePropertiesWithHttpInfo(Requests\getTablePropertiesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TablePropertiesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTablePropertiesAsync
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTablePropertiesAsync(Requests\getTablePropertiesRequest $request) 
    {
        return $this->getTablePropertiesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTablePropertiesAsyncWithHttpInfo
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTablePropertiesAsyncWithHttpInfo(Requests\getTablePropertiesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTablePropertiesOnline
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TablePropertiesResponse
     */
    public function getTablePropertiesOnline(Requests\getTablePropertiesOnlineRequest $request)
    {
        try {
            list($response) = $this->getTablePropertiesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTablePropertiesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTablePropertiesOnlineWithHttpInfo
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TablePropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTablePropertiesOnlineWithHttpInfo(Requests\getTablePropertiesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TablePropertiesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTablePropertiesOnlineAsync
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTablePropertiesOnlineAsync(Requests\getTablePropertiesOnlineRequest $request) 
    {
        return $this->getTablePropertiesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTablePropertiesOnlineAsyncWithHttpInfo
     *
     * Reads properties of a table from the document node.
     *
     * @param Requests\getTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTablePropertiesOnlineAsyncWithHttpInfo(Requests\getTablePropertiesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableRow
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowResponse
     */
    public function getTableRow(Requests\getTableRowRequest $request)
    {
        try {
            list($response) = $this->getTableRowWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableRowWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableRowWithHttpInfo
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableRowWithHttpInfo(Requests\getTableRowRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableRowAsync
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableRowAsync(Requests\getTableRowRequest $request) 
    {
        return $this->getTableRowAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableRowAsyncWithHttpInfo
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableRowAsyncWithHttpInfo(Requests\getTableRowRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableRowFormat
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowFormatResponse
     */
    public function getTableRowFormat(Requests\getTableRowFormatRequest $request)
    {
        try {
            list($response) = $this->getTableRowFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableRowFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableRowFormatWithHttpInfo
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableRowFormatWithHttpInfo(Requests\getTableRowFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableRowFormatAsync
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableRowFormatAsync(Requests\getTableRowFormatRequest $request) 
    {
        return $this->getTableRowFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableRowFormatAsyncWithHttpInfo
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableRowFormatAsyncWithHttpInfo(Requests\getTableRowFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableRowFormatOnline
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowFormatResponse
     */
    public function getTableRowFormatOnline(Requests\getTableRowFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->getTableRowFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableRowFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableRowFormatOnlineWithHttpInfo
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableRowFormatOnlineWithHttpInfo(Requests\getTableRowFormatOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableRowFormatOnlineAsync
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableRowFormatOnlineAsync(Requests\getTableRowFormatOnlineRequest $request) 
    {
        return $this->getTableRowFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableRowFormatOnlineAsyncWithHttpInfo
     *
     * Reads the formatting properties of a table row.
     *
     * @param Requests\getTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableRowFormatOnlineAsyncWithHttpInfo(Requests\getTableRowFormatOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTableRowOnline
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowResponse
     */
    public function getTableRowOnline(Requests\getTableRowOnlineRequest $request)
    {
        try {
            list($response) = $this->getTableRowOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTableRowOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTableRowOnlineWithHttpInfo
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTableRowOnlineWithHttpInfo(Requests\getTableRowOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTableRowOnlineAsync
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableRowOnlineAsync(Requests\getTableRowOnlineRequest $request) 
    {
        return $this->getTableRowOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTableRowOnlineAsyncWithHttpInfo
     *
     * Reads a row from the table.
     *
     * @param Requests\getTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTableRowOnlineAsyncWithHttpInfo(Requests\getTableRowOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTables
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableLinkCollectionResponse
     */
    public function getTables(Requests\getTablesRequest $request)
    {
        try {
            list($response) = $this->getTablesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTablesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTablesWithHttpInfo
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTablesWithHttpInfo(Requests\getTablesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTablesAsync
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTablesAsync(Requests\getTablesRequest $request) 
    {
        return $this->getTablesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTablesAsyncWithHttpInfo
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTablesAsyncWithHttpInfo(Requests\getTablesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation getTablesOnline
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableLinkCollectionResponse
     */
    public function getTablesOnline(Requests\getTablesOnlineRequest $request)
    {
        try {
            list($response) = $this->getTablesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->getTablesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation getTablesOnlineWithHttpInfo
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableLinkCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function getTablesOnlineWithHttpInfo(Requests\getTablesOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableLinkCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableLinkCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation getTablesOnlineAsync
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTablesOnlineAsync(Requests\getTablesOnlineRequest $request) 
    {
        return $this->getTablesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation getTablesOnlineAsyncWithHttpInfo
     *
     * Reads tables from the document node.
     *
     * @param Requests\getTablesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function getTablesOnlineAsyncWithHttpInfo(Requests\getTablesOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableLinkCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertBookmark
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarkResponse
     */
    public function insertBookmark(Requests\insertBookmarkRequest $request)
    {
        try {
            list($response) = $this->insertBookmarkWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertBookmarkWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertBookmarkWithHttpInfo
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertBookmarkWithHttpInfo(Requests\insertBookmarkRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertBookmarkAsync
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBookmarkAsync(Requests\insertBookmarkRequest $request) 
    {
        return $this->insertBookmarkAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertBookmarkAsyncWithHttpInfo
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertBookmarkAsyncWithHttpInfo(Requests\insertBookmarkRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertBookmarkOnline
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertBookmarkOnlineResponse
     */
    public function insertBookmarkOnline(Requests\insertBookmarkOnlineRequest $request)
    {
        try {
            list($response) = $this->insertBookmarkOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertBookmarkOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertBookmarkOnlineWithHttpInfo
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertBookmarkOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertBookmarkOnlineWithHttpInfo(Requests\insertBookmarkOnlineRequest $request)
    {
        $returnType = 'InsertBookmarkOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertBookmarkOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertBookmarkOnlineAsync
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertBookmarkOnlineAsync(Requests\insertBookmarkOnlineRequest $request) 
    {
        return $this->insertBookmarkOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertBookmarkOnlineAsyncWithHttpInfo
     *
     * Inserts a new bookmark to the document.
     *
     * @param Requests\insertBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertBookmarkOnlineAsyncWithHttpInfo(Requests\insertBookmarkOnlineRequest $request) 
    {
        $returnType = 'InsertBookmarkOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertComment
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentResponse
     */
    public function insertComment(Requests\insertCommentRequest $request)
    {
        try {
            list($response) = $this->insertCommentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertCommentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertCommentWithHttpInfo
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertCommentWithHttpInfo(Requests\insertCommentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertCommentAsync
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertCommentAsync(Requests\insertCommentRequest $request) 
    {
        return $this->insertCommentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertCommentAsyncWithHttpInfo
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertCommentAsyncWithHttpInfo(Requests\insertCommentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertCommentOnline
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertCommentOnlineResponse
     */
    public function insertCommentOnline(Requests\insertCommentOnlineRequest $request)
    {
        try {
            list($response) = $this->insertCommentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertCommentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertCommentOnlineWithHttpInfo
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertCommentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertCommentOnlineWithHttpInfo(Requests\insertCommentOnlineRequest $request)
    {
        $returnType = 'InsertCommentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertCommentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertCommentOnlineAsync
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertCommentOnlineAsync(Requests\insertCommentOnlineRequest $request) 
    {
        return $this->insertCommentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertCommentOnlineAsyncWithHttpInfo
     *
     * Inserts a new comment to the document.
     *
     * @param Requests\insertCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertCommentOnlineAsyncWithHttpInfo(Requests\insertCommentOnlineRequest $request) 
    {
        $returnType = 'InsertCommentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertCustomXmlPart
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartResponse
     */
    public function insertCustomXmlPart(Requests\insertCustomXmlPartRequest $request)
    {
        try {
            list($response) = $this->insertCustomXmlPartWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertCustomXmlPartWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertCustomXmlPartWithHttpInfo
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertCustomXmlPartWithHttpInfo(Requests\insertCustomXmlPartRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertCustomXmlPartAsync
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertCustomXmlPartAsync(Requests\insertCustomXmlPartRequest $request) 
    {
        return $this->insertCustomXmlPartAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertCustomXmlPartAsyncWithHttpInfo
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertCustomXmlPartAsyncWithHttpInfo(Requests\insertCustomXmlPartRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertCustomXmlPartOnline
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertCustomXmlPartOnlineResponse
     */
    public function insertCustomXmlPartOnline(Requests\insertCustomXmlPartOnlineRequest $request)
    {
        try {
            list($response) = $this->insertCustomXmlPartOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertCustomXmlPartOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertCustomXmlPartOnlineWithHttpInfo
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertCustomXmlPartOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertCustomXmlPartOnlineWithHttpInfo(Requests\insertCustomXmlPartOnlineRequest $request)
    {
        $returnType = 'InsertCustomXmlPartOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertCustomXmlPartOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertCustomXmlPartOnlineAsync
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertCustomXmlPartOnlineAsync(Requests\insertCustomXmlPartOnlineRequest $request) 
    {
        return $this->insertCustomXmlPartOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertCustomXmlPartOnlineAsyncWithHttpInfo
     *
     * Inserts a new custom xml part to the document.
     *
     * @param Requests\insertCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertCustomXmlPartOnlineAsyncWithHttpInfo(Requests\insertCustomXmlPartOnlineRequest $request) 
    {
        $returnType = 'InsertCustomXmlPartOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertDrawingObject
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectResponse
     */
    public function insertDrawingObject(Requests\insertDrawingObjectRequest $request)
    {
        try {
            list($response) = $this->insertDrawingObjectWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertDrawingObjectWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertDrawingObjectWithHttpInfo
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertDrawingObjectWithHttpInfo(Requests\insertDrawingObjectRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertDrawingObjectAsync
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertDrawingObjectAsync(Requests\insertDrawingObjectRequest $request) 
    {
        return $this->insertDrawingObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertDrawingObjectAsyncWithHttpInfo
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertDrawingObjectAsyncWithHttpInfo(Requests\insertDrawingObjectRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertDrawingObjectOnline
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertDrawingObjectOnlineResponse
     */
    public function insertDrawingObjectOnline(Requests\insertDrawingObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->insertDrawingObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertDrawingObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertDrawingObjectOnlineWithHttpInfo
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertDrawingObjectOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertDrawingObjectOnlineWithHttpInfo(Requests\insertDrawingObjectOnlineRequest $request)
    {
        $returnType = 'InsertDrawingObjectOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertDrawingObjectOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertDrawingObjectOnlineAsync
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertDrawingObjectOnlineAsync(Requests\insertDrawingObjectOnlineRequest $request) 
    {
        return $this->insertDrawingObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertDrawingObjectOnlineAsyncWithHttpInfo
     *
     * Inserts a new DrawingObject to the document node.
     *
     * @param Requests\insertDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertDrawingObjectOnlineAsyncWithHttpInfo(Requests\insertDrawingObjectOnlineRequest $request) 
    {
        $returnType = 'InsertDrawingObjectOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertField
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldResponse
     */
    public function insertField(Requests\insertFieldRequest $request)
    {
        try {
            list($response) = $this->insertFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFieldWithHttpInfo
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFieldWithHttpInfo(Requests\insertFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFieldAsync
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFieldAsync(Requests\insertFieldRequest $request) 
    {
        return $this->insertFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFieldAsyncWithHttpInfo
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFieldAsyncWithHttpInfo(Requests\insertFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertFieldOnline
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertFieldOnlineResponse
     */
    public function insertFieldOnline(Requests\insertFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->insertFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFieldOnlineWithHttpInfo
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertFieldOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFieldOnlineWithHttpInfo(Requests\insertFieldOnlineRequest $request)
    {
        $returnType = 'InsertFieldOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertFieldOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFieldOnlineAsync
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFieldOnlineAsync(Requests\insertFieldOnlineRequest $request) 
    {
        return $this->insertFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFieldOnlineAsyncWithHttpInfo
     *
     * Inserts a new field to the document node.
     *
     * @param Requests\insertFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFieldOnlineAsyncWithHttpInfo(Requests\insertFieldOnlineRequest $request) 
    {
        $returnType = 'InsertFieldOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertFootnote
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnoteResponse
     */
    public function insertFootnote(Requests\insertFootnoteRequest $request)
    {
        try {
            list($response) = $this->insertFootnoteWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFootnoteWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFootnoteWithHttpInfo
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnoteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFootnoteWithHttpInfo(Requests\insertFootnoteRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnoteResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFootnoteAsync
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFootnoteAsync(Requests\insertFootnoteRequest $request) 
    {
        return $this->insertFootnoteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFootnoteAsyncWithHttpInfo
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFootnoteAsyncWithHttpInfo(Requests\insertFootnoteRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertFootnoteOnline
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertFootnoteOnlineResponse
     */
    public function insertFootnoteOnline(Requests\insertFootnoteOnlineRequest $request)
    {
        try {
            list($response) = $this->insertFootnoteOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFootnoteOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFootnoteOnlineWithHttpInfo
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertFootnoteOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFootnoteOnlineWithHttpInfo(Requests\insertFootnoteOnlineRequest $request)
    {
        $returnType = 'InsertFootnoteOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertFootnoteOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFootnoteOnlineAsync
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFootnoteOnlineAsync(Requests\insertFootnoteOnlineRequest $request) 
    {
        return $this->insertFootnoteOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFootnoteOnlineAsyncWithHttpInfo
     *
     * Inserts a new footnote to the document node.
     *
     * @param Requests\insertFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFootnoteOnlineAsyncWithHttpInfo(Requests\insertFootnoteOnlineRequest $request) 
    {
        $returnType = 'InsertFootnoteOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertFormField
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldResponse
     */
    public function insertFormField(Requests\insertFormFieldRequest $request)
    {
        try {
            list($response) = $this->insertFormFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFormFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFormFieldWithHttpInfo
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFormFieldWithHttpInfo(Requests\insertFormFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFormFieldAsync
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFormFieldAsync(Requests\insertFormFieldRequest $request) 
    {
        return $this->insertFormFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFormFieldAsyncWithHttpInfo
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFormFieldAsyncWithHttpInfo(Requests\insertFormFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertFormFieldOnline
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertFormFieldOnlineResponse
     */
    public function insertFormFieldOnline(Requests\insertFormFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->insertFormFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertFormFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertFormFieldOnlineWithHttpInfo
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertFormFieldOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertFormFieldOnlineWithHttpInfo(Requests\insertFormFieldOnlineRequest $request)
    {
        $returnType = 'InsertFormFieldOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertFormFieldOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertFormFieldOnlineAsync
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFormFieldOnlineAsync(Requests\insertFormFieldOnlineRequest $request) 
    {
        return $this->insertFormFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertFormFieldOnlineAsyncWithHttpInfo
     *
     * Inserts a new form field to the document node.
     *
     * @param Requests\insertFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertFormFieldOnlineAsyncWithHttpInfo(Requests\insertFormFieldOnlineRequest $request) 
    {
        $returnType = 'InsertFormFieldOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertHeaderFooter
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\HeaderFooterResponse
     */
    public function insertHeaderFooter(Requests\insertHeaderFooterRequest $request)
    {
        try {
            list($response) = $this->insertHeaderFooterWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertHeaderFooterWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertHeaderFooterWithHttpInfo
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\HeaderFooterResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertHeaderFooterWithHttpInfo(Requests\insertHeaderFooterRequest $request)
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\HeaderFooterResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertHeaderFooterAsync
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertHeaderFooterAsync(Requests\insertHeaderFooterRequest $request) 
    {
        return $this->insertHeaderFooterAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertHeaderFooterAsyncWithHttpInfo
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertHeaderFooterAsyncWithHttpInfo(Requests\insertHeaderFooterRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\HeaderFooterResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertHeaderFooterOnline
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertHeaderFooterOnlineResponse
     */
    public function insertHeaderFooterOnline(Requests\insertHeaderFooterOnlineRequest $request)
    {
        try {
            list($response) = $this->insertHeaderFooterOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertHeaderFooterOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertHeaderFooterOnlineWithHttpInfo
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertHeaderFooterOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertHeaderFooterOnlineWithHttpInfo(Requests\insertHeaderFooterOnlineRequest $request)
    {
        $returnType = 'InsertHeaderFooterOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertHeaderFooterOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertHeaderFooterOnlineAsync
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertHeaderFooterOnlineAsync(Requests\insertHeaderFooterOnlineRequest $request) 
    {
        return $this->insertHeaderFooterOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertHeaderFooterOnlineAsyncWithHttpInfo
     *
     * Inserts a new HeaderFooter object to the document section.
     *
     * @param Requests\insertHeaderFooterOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertHeaderFooterOnlineAsyncWithHttpInfo(Requests\insertHeaderFooterOnlineRequest $request) 
    {
        $returnType = 'InsertHeaderFooterOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertList
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListResponse
     */
    public function insertList(Requests\insertListRequest $request)
    {
        try {
            list($response) = $this->insertListWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertListWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertListWithHttpInfo
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertListWithHttpInfo(Requests\insertListRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertListAsync
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertListAsync(Requests\insertListRequest $request) 
    {
        return $this->insertListAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertListAsyncWithHttpInfo
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertListAsyncWithHttpInfo(Requests\insertListRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertListOnline
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertListOnlineResponse
     */
    public function insertListOnline(Requests\insertListOnlineRequest $request)
    {
        try {
            list($response) = $this->insertListOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertListOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertListOnlineWithHttpInfo
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertListOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertListOnlineWithHttpInfo(Requests\insertListOnlineRequest $request)
    {
        $returnType = 'InsertListOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertListOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertListOnlineAsync
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertListOnlineAsync(Requests\insertListOnlineRequest $request) 
    {
        return $this->insertListOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertListOnlineAsyncWithHttpInfo
     *
     * Inserts a new list to the document.
     *
     * @param Requests\insertListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertListOnlineAsyncWithHttpInfo(Requests\insertListOnlineRequest $request) 
    {
        $returnType = 'InsertListOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertOrUpdateParagraphTabStop
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TabStopsResponse
     */
    public function insertOrUpdateParagraphTabStop(Requests\insertOrUpdateParagraphTabStopRequest $request)
    {
        try {
            list($response) = $this->insertOrUpdateParagraphTabStopWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertOrUpdateParagraphTabStopWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertOrUpdateParagraphTabStopWithHttpInfo
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TabStopsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertOrUpdateParagraphTabStopWithHttpInfo(Requests\insertOrUpdateParagraphTabStopRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TabStopsResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertOrUpdateParagraphTabStopAsync
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertOrUpdateParagraphTabStopAsync(Requests\insertOrUpdateParagraphTabStopRequest $request) 
    {
        return $this->insertOrUpdateParagraphTabStopAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertOrUpdateParagraphTabStopAsyncWithHttpInfo
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertOrUpdateParagraphTabStopAsyncWithHttpInfo(Requests\insertOrUpdateParagraphTabStopRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TabStopsResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertOrUpdateParagraphTabStopOnline
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertOrUpdateParagraphTabStopOnlineResponse
     */
    public function insertOrUpdateParagraphTabStopOnline(Requests\insertOrUpdateParagraphTabStopOnlineRequest $request)
    {
        try {
            list($response) = $this->insertOrUpdateParagraphTabStopOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertOrUpdateParagraphTabStopOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertOrUpdateParagraphTabStopOnlineWithHttpInfo
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertOrUpdateParagraphTabStopOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertOrUpdateParagraphTabStopOnlineWithHttpInfo(Requests\insertOrUpdateParagraphTabStopOnlineRequest $request)
    {
        $returnType = 'InsertOrUpdateParagraphTabStopOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertOrUpdateParagraphTabStopOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertOrUpdateParagraphTabStopOnlineAsync
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertOrUpdateParagraphTabStopOnlineAsync(Requests\insertOrUpdateParagraphTabStopOnlineRequest $request) 
    {
        return $this->insertOrUpdateParagraphTabStopOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertOrUpdateParagraphTabStopOnlineAsyncWithHttpInfo
     *
     * Inserts a new or updates an existing paragraph tab stop in the document node.
     *
     * @param Requests\insertOrUpdateParagraphTabStopOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertOrUpdateParagraphTabStopOnlineAsyncWithHttpInfo(Requests\insertOrUpdateParagraphTabStopOnlineRequest $request) 
    {
        $returnType = 'InsertOrUpdateParagraphTabStopOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertPageNumbers
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function insertPageNumbers(Requests\insertPageNumbersRequest $request)
    {
        try {
            list($response) = $this->insertPageNumbersWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertPageNumbersWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertPageNumbersWithHttpInfo
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertPageNumbersWithHttpInfo(Requests\insertPageNumbersRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertPageNumbersAsync
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPageNumbersAsync(Requests\insertPageNumbersRequest $request) 
    {
        return $this->insertPageNumbersAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertPageNumbersAsyncWithHttpInfo
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertPageNumbersAsyncWithHttpInfo(Requests\insertPageNumbersRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertPageNumbersOnline
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertPageNumbersOnlineResponse
     */
    public function insertPageNumbersOnline(Requests\insertPageNumbersOnlineRequest $request)
    {
        try {
            list($response) = $this->insertPageNumbersOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertPageNumbersOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertPageNumbersOnlineWithHttpInfo
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertPageNumbersOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertPageNumbersOnlineWithHttpInfo(Requests\insertPageNumbersOnlineRequest $request)
    {
        $returnType = 'InsertPageNumbersOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertPageNumbersOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertPageNumbersOnlineAsync
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPageNumbersOnlineAsync(Requests\insertPageNumbersOnlineRequest $request) 
    {
        return $this->insertPageNumbersOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertPageNumbersOnlineAsyncWithHttpInfo
     *
     * Inserts page numbers to the document.
     *
     * @param Requests\insertPageNumbersOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertPageNumbersOnlineAsyncWithHttpInfo(Requests\insertPageNumbersOnlineRequest $request) 
    {
        $returnType = 'InsertPageNumbersOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertParagraph
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphResponse
     */
    public function insertParagraph(Requests\insertParagraphRequest $request)
    {
        try {
            list($response) = $this->insertParagraphWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertParagraphWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertParagraphWithHttpInfo
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertParagraphWithHttpInfo(Requests\insertParagraphRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertParagraphAsync
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertParagraphAsync(Requests\insertParagraphRequest $request) 
    {
        return $this->insertParagraphAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertParagraphAsyncWithHttpInfo
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertParagraphAsyncWithHttpInfo(Requests\insertParagraphRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertParagraphOnline
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertParagraphOnlineResponse
     */
    public function insertParagraphOnline(Requests\insertParagraphOnlineRequest $request)
    {
        try {
            list($response) = $this->insertParagraphOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertParagraphOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertParagraphOnlineWithHttpInfo
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertParagraphOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertParagraphOnlineWithHttpInfo(Requests\insertParagraphOnlineRequest $request)
    {
        $returnType = 'InsertParagraphOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertParagraphOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertParagraphOnlineAsync
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertParagraphOnlineAsync(Requests\insertParagraphOnlineRequest $request) 
    {
        return $this->insertParagraphOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertParagraphOnlineAsyncWithHttpInfo
     *
     * Inserts a new paragraph to the document node.
     *
     * @param Requests\insertParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertParagraphOnlineAsyncWithHttpInfo(Requests\insertParagraphOnlineRequest $request) 
    {
        $returnType = 'InsertParagraphOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertRun
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunResponse
     */
    public function insertRun(Requests\insertRunRequest $request)
    {
        try {
            list($response) = $this->insertRunWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertRunWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertRunWithHttpInfo
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertRunWithHttpInfo(Requests\insertRunRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertRunAsync
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertRunAsync(Requests\insertRunRequest $request) 
    {
        return $this->insertRunAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertRunAsyncWithHttpInfo
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertRunAsyncWithHttpInfo(Requests\insertRunRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertRunOnline
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertRunOnlineResponse
     */
    public function insertRunOnline(Requests\insertRunOnlineRequest $request)
    {
        try {
            list($response) = $this->insertRunOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertRunOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertRunOnlineWithHttpInfo
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertRunOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertRunOnlineWithHttpInfo(Requests\insertRunOnlineRequest $request)
    {
        $returnType = 'InsertRunOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertRunOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertRunOnlineAsync
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertRunOnlineAsync(Requests\insertRunOnlineRequest $request) 
    {
        return $this->insertRunOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertRunOnlineAsyncWithHttpInfo
     *
     * Inserts a new Run object to the paragraph.
     *
     * @param Requests\insertRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertRunOnlineAsyncWithHttpInfo(Requests\insertRunOnlineRequest $request) 
    {
        $returnType = 'InsertRunOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertSection
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function insertSection(Requests\insertSectionRequest $request)
    {
        try {
    $this->insertSectionWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->insertSectionWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertSectionWithHttpInfo
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertSectionWithHttpInfo(Requests\insertSectionRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation insertSectionAsync
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSectionAsync(Requests\insertSectionRequest $request) 
    {
        return $this->insertSectionAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertSectionAsyncWithHttpInfo
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertSectionAsyncWithHttpInfo(Requests\insertSectionRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertSectionOnline
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function insertSectionOnline(Requests\insertSectionOnlineRequest $request)
    {
        try {
            list($response) = $this->insertSectionOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertSectionOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertSectionOnlineWithHttpInfo
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertSectionOnlineWithHttpInfo(Requests\insertSectionOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertSectionOnlineAsync
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertSectionOnlineAsync(Requests\insertSectionOnlineRequest $request) 
    {
        return $this->insertSectionOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertSectionOnlineAsyncWithHttpInfo
     *
     * Inserts a section to the document.
     *
     * @param Requests\insertSectionOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertSectionOnlineAsyncWithHttpInfo(Requests\insertSectionOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertStructuredDocumentTag
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagResponse
     */
    public function insertStructuredDocumentTag(Requests\insertStructuredDocumentTagRequest $request)
    {
        try {
            list($response) = $this->insertStructuredDocumentTagWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertStructuredDocumentTagWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertStructuredDocumentTagWithHttpInfo
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertStructuredDocumentTagWithHttpInfo(Requests\insertStructuredDocumentTagRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertStructuredDocumentTagAsync
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertStructuredDocumentTagAsync(Requests\insertStructuredDocumentTagRequest $request) 
    {
        return $this->insertStructuredDocumentTagAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertStructuredDocumentTagAsyncWithHttpInfo
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertStructuredDocumentTagAsyncWithHttpInfo(Requests\insertStructuredDocumentTagRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertStructuredDocumentTagOnline
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertStructuredDocumentTagOnlineResponse
     */
    public function insertStructuredDocumentTagOnline(Requests\insertStructuredDocumentTagOnlineRequest $request)
    {
        try {
            list($response) = $this->insertStructuredDocumentTagOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertStructuredDocumentTagOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertStructuredDocumentTagOnlineWithHttpInfo
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertStructuredDocumentTagOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertStructuredDocumentTagOnlineWithHttpInfo(Requests\insertStructuredDocumentTagOnlineRequest $request)
    {
        $returnType = 'InsertStructuredDocumentTagOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertStructuredDocumentTagOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertStructuredDocumentTagOnlineAsync
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertStructuredDocumentTagOnlineAsync(Requests\insertStructuredDocumentTagOnlineRequest $request) 
    {
        return $this->insertStructuredDocumentTagOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertStructuredDocumentTagOnlineAsyncWithHttpInfo
     *
     * Inserts a new StructuredDocumentTag (SDT) to the document node.
     *
     * @param Requests\insertStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertStructuredDocumentTagOnlineAsyncWithHttpInfo(Requests\insertStructuredDocumentTagOnlineRequest $request) 
    {
        $returnType = 'InsertStructuredDocumentTagOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertStyle
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function insertStyle(Requests\insertStyleRequest $request)
    {
        try {
            list($response) = $this->insertStyleWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertStyleWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertStyleWithHttpInfo
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertStyleWithHttpInfo(Requests\insertStyleRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertStyleAsync
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertStyleAsync(Requests\insertStyleRequest $request) 
    {
        return $this->insertStyleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertStyleAsyncWithHttpInfo
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertStyleAsyncWithHttpInfo(Requests\insertStyleRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertStyleOnline
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertStyleOnlineResponse
     */
    public function insertStyleOnline(Requests\insertStyleOnlineRequest $request)
    {
        try {
            list($response) = $this->insertStyleOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertStyleOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertStyleOnlineWithHttpInfo
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertStyleOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertStyleOnlineWithHttpInfo(Requests\insertStyleOnlineRequest $request)
    {
        $returnType = 'InsertStyleOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertStyleOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertStyleOnlineAsync
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertStyleOnlineAsync(Requests\insertStyleOnlineRequest $request) 
    {
        return $this->insertStyleOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertStyleOnlineAsyncWithHttpInfo
     *
     * Inserts a new style to the document.
     *
     * @param Requests\insertStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertStyleOnlineAsyncWithHttpInfo(Requests\insertStyleOnlineRequest $request) 
    {
        $returnType = 'InsertStyleOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTable
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableResponse
     */
    public function insertTable(Requests\insertTableRequest $request)
    {
        try {
            list($response) = $this->insertTableWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableWithHttpInfo
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableWithHttpInfo(Requests\insertTableRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableAsync
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableAsync(Requests\insertTableRequest $request) 
    {
        return $this->insertTableAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableAsyncWithHttpInfo
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableAsyncWithHttpInfo(Requests\insertTableRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTableCell
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellResponse
     */
    public function insertTableCell(Requests\insertTableCellRequest $request)
    {
        try {
            list($response) = $this->insertTableCellWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableCellWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableCellWithHttpInfo
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableCellWithHttpInfo(Requests\insertTableCellRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableCellAsync
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableCellAsync(Requests\insertTableCellRequest $request) 
    {
        return $this->insertTableCellAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableCellAsyncWithHttpInfo
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableCellAsyncWithHttpInfo(Requests\insertTableCellRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTableCellOnline
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertTableCellOnlineResponse
     */
    public function insertTableCellOnline(Requests\insertTableCellOnlineRequest $request)
    {
        try {
            list($response) = $this->insertTableCellOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableCellOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableCellOnlineWithHttpInfo
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertTableCellOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableCellOnlineWithHttpInfo(Requests\insertTableCellOnlineRequest $request)
    {
        $returnType = 'InsertTableCellOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertTableCellOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableCellOnlineAsync
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableCellOnlineAsync(Requests\insertTableCellOnlineRequest $request) 
    {
        return $this->insertTableCellOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableCellOnlineAsyncWithHttpInfo
     *
     * Inserts a new cell to the table row.
     *
     * @param Requests\insertTableCellOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableCellOnlineAsyncWithHttpInfo(Requests\insertTableCellOnlineRequest $request) 
    {
        $returnType = 'InsertTableCellOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTableOnline
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertTableOnlineResponse
     */
    public function insertTableOnline(Requests\insertTableOnlineRequest $request)
    {
        try {
            list($response) = $this->insertTableOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableOnlineWithHttpInfo
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertTableOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableOnlineWithHttpInfo(Requests\insertTableOnlineRequest $request)
    {
        $returnType = 'InsertTableOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertTableOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableOnlineAsync
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableOnlineAsync(Requests\insertTableOnlineRequest $request) 
    {
        return $this->insertTableOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableOnlineAsyncWithHttpInfo
     *
     * Inserts a new table to the document node.
     *
     * @param Requests\insertTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableOnlineAsyncWithHttpInfo(Requests\insertTableOnlineRequest $request) 
    {
        $returnType = 'InsertTableOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTableRow
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowResponse
     */
    public function insertTableRow(Requests\insertTableRowRequest $request)
    {
        try {
            list($response) = $this->insertTableRowWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableRowWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableRowWithHttpInfo
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableRowWithHttpInfo(Requests\insertTableRowRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableRowAsync
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableRowAsync(Requests\insertTableRowRequest $request) 
    {
        return $this->insertTableRowAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableRowAsyncWithHttpInfo
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableRowAsyncWithHttpInfo(Requests\insertTableRowRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertTableRowOnline
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertTableRowOnlineResponse
     */
    public function insertTableRowOnline(Requests\insertTableRowOnlineRequest $request)
    {
        try {
            list($response) = $this->insertTableRowOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertTableRowOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertTableRowOnlineWithHttpInfo
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertTableRowOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertTableRowOnlineWithHttpInfo(Requests\insertTableRowOnlineRequest $request)
    {
        $returnType = 'InsertTableRowOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertTableRowOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertTableRowOnlineAsync
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertTableRowOnlineAsync(Requests\insertTableRowOnlineRequest $request) 
    {
        return $this->insertTableRowOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertTableRowOnlineAsyncWithHttpInfo
     *
     * Inserts a new row to the table.
     *
     * @param Requests\insertTableRowOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertTableRowOnlineAsyncWithHttpInfo(Requests\insertTableRowOnlineRequest $request) 
    {
        $returnType = 'InsertTableRowOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermark
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function insertWatermark(Requests\insertWatermarkRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkWithHttpInfo
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkWithHttpInfo(Requests\insertWatermarkRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkAsync
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkAsync(Requests\insertWatermarkRequest $request) 
    {
        return $this->insertWatermarkAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkAsyncWithHttpInfo
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkAsyncWithHttpInfo(Requests\insertWatermarkRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermarkImage
     *
     * Inserts a new watermark image to the document.
     * @deprecated This operation is deprecated and is used for backward compatibility only. Please use InsertWatermark instead.
     *
     * @param Requests\insertWatermarkImageRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function insertWatermarkImage(Requests\insertWatermarkImageRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkImageWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkImageWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkImageWithHttpInfo
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkImageWithHttpInfo(Requests\insertWatermarkImageRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkImageAsync
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkImageAsync(Requests\insertWatermarkImageRequest $request) 
    {
        return $this->insertWatermarkImageAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkImageAsyncWithHttpInfo
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkImageAsyncWithHttpInfo(Requests\insertWatermarkImageRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermarkImageOnline
     *
     * Inserts a new watermark image to the document.
     * @deprecated This operation is deprecated and is used for backward compatibility only. Please use InsertWatermark instead.
     *
     * @param Requests\insertWatermarkImageOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertWatermarkImageOnlineResponse
     */
    public function insertWatermarkImageOnline(Requests\insertWatermarkImageOnlineRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkImageOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkImageOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkImageOnlineWithHttpInfo
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertWatermarkImageOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkImageOnlineWithHttpInfo(Requests\insertWatermarkImageOnlineRequest $request)
    {
        $returnType = 'InsertWatermarkImageOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertWatermarkImageOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkImageOnlineAsync
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkImageOnlineAsync(Requests\insertWatermarkImageOnlineRequest $request) 
    {
        return $this->insertWatermarkImageOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkImageOnlineAsyncWithHttpInfo
     *
     * Inserts a new watermark image to the document.
     *
     * @param Requests\insertWatermarkImageOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkImageOnlineAsyncWithHttpInfo(Requests\insertWatermarkImageOnlineRequest $request) 
    {
        $returnType = 'InsertWatermarkImageOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermarkOnline
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertWatermarkOnlineResponse
     */
    public function insertWatermarkOnline(Requests\insertWatermarkOnlineRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkOnlineWithHttpInfo
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertWatermarkOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkOnlineWithHttpInfo(Requests\insertWatermarkOnlineRequest $request)
    {
        $returnType = 'InsertWatermarkOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertWatermarkOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkOnlineAsync
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkOnlineAsync(Requests\insertWatermarkOnlineRequest $request) 
    {
        return $this->insertWatermarkOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkOnlineAsyncWithHttpInfo
     *
     * Insert a watermark to the document.
     *
     * @param Requests\insertWatermarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkOnlineAsyncWithHttpInfo(Requests\insertWatermarkOnlineRequest $request) 
    {
        $returnType = 'InsertWatermarkOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermarkText
     *
     * Inserts a new watermark text to the document.
     * @deprecated This operation is deprecated and is used for backward compatibility only. Please use InsertWatermark instead.
     *
     * @param Requests\insertWatermarkTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function insertWatermarkText(Requests\insertWatermarkTextRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkTextWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkTextWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkTextWithHttpInfo
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkTextWithHttpInfo(Requests\insertWatermarkTextRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkTextAsync
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkTextAsync(Requests\insertWatermarkTextRequest $request) 
    {
        return $this->insertWatermarkTextAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkTextAsyncWithHttpInfo
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkTextAsyncWithHttpInfo(Requests\insertWatermarkTextRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation insertWatermarkTextOnline
     *
     * Inserts a new watermark text to the document.
     * @deprecated This operation is deprecated and is used for backward compatibility only. Please use InsertWatermark instead.
     *
     * @param Requests\insertWatermarkTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return InsertWatermarkTextOnlineResponse
     */
    public function insertWatermarkTextOnline(Requests\insertWatermarkTextOnlineRequest $request)
    {
        try {
            list($response) = $this->insertWatermarkTextOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->insertWatermarkTextOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation insertWatermarkTextOnlineWithHttpInfo
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of InsertWatermarkTextOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function insertWatermarkTextOnlineWithHttpInfo(Requests\insertWatermarkTextOnlineRequest $request)
    {
        $returnType = 'InsertWatermarkTextOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'InsertWatermarkTextOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation insertWatermarkTextOnlineAsync
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertWatermarkTextOnlineAsync(Requests\insertWatermarkTextOnlineRequest $request) 
    {
        return $this->insertWatermarkTextOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation insertWatermarkTextOnlineAsyncWithHttpInfo
     *
     * Inserts a new watermark text to the document.
     *
     * @param Requests\insertWatermarkTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function insertWatermarkTextOnlineAsyncWithHttpInfo(Requests\insertWatermarkTextOnlineRequest $request) 
    {
        $returnType = 'InsertWatermarkTextOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation linkHeaderFootersToPrevious
     *
     * Links headers / footers of the section to the previous one.
     *
     * @param Requests\linkHeaderFootersToPreviousRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function linkHeaderFootersToPrevious(Requests\linkHeaderFootersToPreviousRequest $request)
    {
        try {
    $this->linkHeaderFootersToPreviousWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->linkHeaderFootersToPreviousWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation linkHeaderFootersToPreviousWithHttpInfo
     *
     * Links headers / footers of the section to the previous one.
     *
     * @param Requests\linkHeaderFootersToPreviousRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function linkHeaderFootersToPreviousWithHttpInfo(Requests\linkHeaderFootersToPreviousRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation linkHeaderFootersToPreviousAsync
     *
     * Links headers / footers of the section to the previous one.
     *
     * @param Requests\linkHeaderFootersToPreviousRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function linkHeaderFootersToPreviousAsync(Requests\linkHeaderFootersToPreviousRequest $request) 
    {
        return $this->linkHeaderFootersToPreviousAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation linkHeaderFootersToPreviousAsyncWithHttpInfo
     *
     * Links headers / footers of the section to the previous one.
     *
     * @param Requests\linkHeaderFootersToPreviousRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function linkHeaderFootersToPreviousAsyncWithHttpInfo(Requests\linkHeaderFootersToPreviousRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation loadWebDocument
     *
     * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
     *
     * @param Requests\loadWebDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SaveResponse
     */
    public function loadWebDocument(Requests\loadWebDocumentRequest $request)
    {
        try {
            list($response) = $this->loadWebDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->loadWebDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation loadWebDocumentWithHttpInfo
     *
     * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
     *
     * @param Requests\loadWebDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function loadWebDocumentWithHttpInfo(Requests\loadWebDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation loadWebDocumentAsync
     *
     * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
     *
     * @param Requests\loadWebDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function loadWebDocumentAsync(Requests\loadWebDocumentRequest $request) 
    {
        return $this->loadWebDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation loadWebDocumentAsyncWithHttpInfo
     *
     * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
     *
     * @param Requests\loadWebDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function loadWebDocumentAsyncWithHttpInfo(Requests\loadWebDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation mergeWithNext
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function mergeWithNext(Requests\mergeWithNextRequest $request)
    {
        try {
    $this->mergeWithNextWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->mergeWithNextWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation mergeWithNextWithHttpInfo
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function mergeWithNextWithHttpInfo(Requests\mergeWithNextRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation mergeWithNextAsync
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeWithNextAsync(Requests\mergeWithNextRequest $request) 
    {
        return $this->mergeWithNextAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation mergeWithNextAsyncWithHttpInfo
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function mergeWithNextAsyncWithHttpInfo(Requests\mergeWithNextRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation mergeWithNextOnline
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function mergeWithNextOnline(Requests\mergeWithNextOnlineRequest $request)
    {
        try {
            list($response) = $this->mergeWithNextOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->mergeWithNextOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation mergeWithNextOnlineWithHttpInfo
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function mergeWithNextOnlineWithHttpInfo(Requests\mergeWithNextOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation mergeWithNextOnlineAsync
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeWithNextOnlineAsync(Requests\mergeWithNextOnlineRequest $request) 
    {
        return $this->mergeWithNextOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation mergeWithNextOnlineAsyncWithHttpInfo
     *
     * Merge the section with the next one.
     *
     * @param Requests\mergeWithNextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function mergeWithNextOnlineAsyncWithHttpInfo(Requests\mergeWithNextOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation moveFile
     *
     * Move file.
     *
     * @param Requests\moveFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function moveFile(Requests\moveFileRequest $request)
    {
        try {
    $this->moveFileWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->moveFileWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation moveFileWithHttpInfo
     *
     * Move file.
     *
     * @param Requests\moveFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function moveFileWithHttpInfo(Requests\moveFileRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation moveFileAsync
     *
     * Move file.
     *
     * @param Requests\moveFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveFileAsync(Requests\moveFileRequest $request) 
    {
        return $this->moveFileAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation moveFileAsyncWithHttpInfo
     *
     * Move file.
     *
     * @param Requests\moveFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function moveFileAsyncWithHttpInfo(Requests\moveFileRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation moveFolder
     *
     * Move folder.
     *
     * @param Requests\moveFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function moveFolder(Requests\moveFolderRequest $request)
    {
        try {
    $this->moveFolderWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->moveFolderWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation moveFolderWithHttpInfo
     *
     * Move folder.
     *
     * @param Requests\moveFolderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function moveFolderWithHttpInfo(Requests\moveFolderRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation moveFolderAsync
     *
     * Move folder.
     *
     * @param Requests\moveFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveFolderAsync(Requests\moveFolderRequest $request) 
    {
        return $this->moveFolderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation moveFolderAsyncWithHttpInfo
     *
     * Move folder.
     *
     * @param Requests\moveFolderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function moveFolderAsyncWithHttpInfo(Requests\moveFolderRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation optimizeDocument
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function optimizeDocument(Requests\optimizeDocumentRequest $request)
    {
        try {
    $this->optimizeDocumentWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->optimizeDocumentWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation optimizeDocumentWithHttpInfo
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function optimizeDocumentWithHttpInfo(Requests\optimizeDocumentRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation optimizeDocumentAsync
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function optimizeDocumentAsync(Requests\optimizeDocumentRequest $request) 
    {
        return $this->optimizeDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation optimizeDocumentAsyncWithHttpInfo
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function optimizeDocumentAsyncWithHttpInfo(Requests\optimizeDocumentRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation optimizeDocumentOnline
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return FILES_COLLECTION
     */
    public function optimizeDocumentOnline(Requests\optimizeDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->optimizeDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->optimizeDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation optimizeDocumentOnlineWithHttpInfo
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of FILES_COLLECTION, HTTP status code, HTTP response headers (array of strings)
     */
    private function optimizeDocumentOnlineWithHttpInfo(Requests\optimizeDocumentOnlineRequest $request)
    {
        $returnType = 'FILES_COLLECTION';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'FILES_COLLECTION', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation optimizeDocumentOnlineAsync
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function optimizeDocumentOnlineAsync(Requests\optimizeDocumentOnlineRequest $request) 
    {
        return $this->optimizeDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation optimizeDocumentOnlineAsyncWithHttpInfo
     *
     * Applies document content optimization options, specific to a particular versions of Microsoft Word.
     *
     * @param Requests\optimizeDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function optimizeDocumentOnlineAsyncWithHttpInfo(Requests\optimizeDocumentOnlineRequest $request) 
    {
        $returnType = 'FILES_COLLECTION';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation protectDocument
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ProtectionDataResponse
     */
    public function protectDocument(Requests\protectDocumentRequest $request)
    {
        try {
            list($response) = $this->protectDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->protectDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation protectDocumentWithHttpInfo
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ProtectionDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function protectDocumentWithHttpInfo(Requests\protectDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ProtectionDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation protectDocumentAsync
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function protectDocumentAsync(Requests\protectDocumentRequest $request) 
    {
        return $this->protectDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation protectDocumentAsyncWithHttpInfo
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function protectDocumentAsyncWithHttpInfo(Requests\protectDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation protectDocumentOnline
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return ProtectDocumentOnlineResponse
     */
    public function protectDocumentOnline(Requests\protectDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->protectDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->protectDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation protectDocumentOnlineWithHttpInfo
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of ProtectDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function protectDocumentOnlineWithHttpInfo(Requests\protectDocumentOnlineRequest $request)
    {
        $returnType = 'ProtectDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'ProtectDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation protectDocumentOnlineAsync
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function protectDocumentOnlineAsync(Requests\protectDocumentOnlineRequest $request) 
    {
        return $this->protectDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation protectDocumentOnlineAsyncWithHttpInfo
     *
     * Changes the document protection. The previous protection will be overwritten if it exist.
     *
     * @param Requests\protectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function protectDocumentOnlineAsyncWithHttpInfo(Requests\protectDocumentOnlineRequest $request) 
    {
        $returnType = 'ProtectDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation rejectAllRevisions
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RevisionsModificationResponse
     */
    public function rejectAllRevisions(Requests\rejectAllRevisionsRequest $request)
    {
        try {
            list($response) = $this->rejectAllRevisionsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->rejectAllRevisionsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation rejectAllRevisionsWithHttpInfo
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RevisionsModificationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function rejectAllRevisionsWithHttpInfo(Requests\rejectAllRevisionsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RevisionsModificationResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RevisionsModificationResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation rejectAllRevisionsAsync
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectAllRevisionsAsync(Requests\rejectAllRevisionsRequest $request) 
    {
        return $this->rejectAllRevisionsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation rejectAllRevisionsAsyncWithHttpInfo
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function rejectAllRevisionsAsyncWithHttpInfo(Requests\rejectAllRevisionsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RevisionsModificationResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation rejectAllRevisionsOnline
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return RejectAllRevisionsOnlineResponse
     */
    public function rejectAllRevisionsOnline(Requests\rejectAllRevisionsOnlineRequest $request)
    {
        try {
            list($response) = $this->rejectAllRevisionsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->rejectAllRevisionsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation rejectAllRevisionsOnlineWithHttpInfo
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of RejectAllRevisionsOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function rejectAllRevisionsOnlineWithHttpInfo(Requests\rejectAllRevisionsOnlineRequest $request)
    {
        $returnType = 'RejectAllRevisionsOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'RejectAllRevisionsOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation rejectAllRevisionsOnlineAsync
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rejectAllRevisionsOnlineAsync(Requests\rejectAllRevisionsOnlineRequest $request) 
    {
        return $this->rejectAllRevisionsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation rejectAllRevisionsOnlineAsyncWithHttpInfo
     *
     * Rejects all revisions in the document.
     *
     * @param Requests\rejectAllRevisionsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function rejectAllRevisionsOnlineAsyncWithHttpInfo(Requests\rejectAllRevisionsOnlineRequest $request) 
    {
        $returnType = 'RejectAllRevisionsOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation removeAllSignatures
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SignatureCollectionResponse
     */
    public function removeAllSignatures(Requests\removeAllSignaturesRequest $request)
    {
        try {
            list($response) = $this->removeAllSignaturesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->removeAllSignaturesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation removeAllSignaturesWithHttpInfo
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SignatureCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function removeAllSignaturesWithHttpInfo(Requests\removeAllSignaturesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SignatureCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation removeAllSignaturesAsync
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllSignaturesAsync(Requests\removeAllSignaturesRequest $request) 
    {
        return $this->removeAllSignaturesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation removeAllSignaturesAsyncWithHttpInfo
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function removeAllSignaturesAsyncWithHttpInfo(Requests\removeAllSignaturesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation removeAllSignaturesOnline
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return RemoveAllSignaturesOnlineResponse
     */
    public function removeAllSignaturesOnline(Requests\removeAllSignaturesOnlineRequest $request)
    {
        try {
            list($response) = $this->removeAllSignaturesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->removeAllSignaturesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation removeAllSignaturesOnlineWithHttpInfo
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of RemoveAllSignaturesOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function removeAllSignaturesOnlineWithHttpInfo(Requests\removeAllSignaturesOnlineRequest $request)
    {
        $returnType = 'RemoveAllSignaturesOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'RemoveAllSignaturesOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation removeAllSignaturesOnlineAsync
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllSignaturesOnlineAsync(Requests\removeAllSignaturesOnlineRequest $request) 
    {
        return $this->removeAllSignaturesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation removeAllSignaturesOnlineAsyncWithHttpInfo
     *
     * Removes all signatures of the document.
     *
     * @param Requests\removeAllSignaturesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function removeAllSignaturesOnlineAsyncWithHttpInfo(Requests\removeAllSignaturesOnlineRequest $request) 
    {
        $returnType = 'RemoveAllSignaturesOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation removeRange
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function removeRange(Requests\removeRangeRequest $request)
    {
        try {
            list($response) = $this->removeRangeWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->removeRangeWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation removeRangeWithHttpInfo
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function removeRangeWithHttpInfo(Requests\removeRangeRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation removeRangeAsync
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeRangeAsync(Requests\removeRangeRequest $request) 
    {
        return $this->removeRangeAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation removeRangeAsyncWithHttpInfo
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function removeRangeAsyncWithHttpInfo(Requests\removeRangeRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation removeRangeOnline
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return RemoveRangeOnlineResponse
     */
    public function removeRangeOnline(Requests\removeRangeOnlineRequest $request)
    {
        try {
            list($response) = $this->removeRangeOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->removeRangeOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation removeRangeOnlineWithHttpInfo
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of RemoveRangeOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function removeRangeOnlineWithHttpInfo(Requests\removeRangeOnlineRequest $request)
    {
        $returnType = 'RemoveRangeOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'RemoveRangeOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation removeRangeOnlineAsync
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeRangeOnlineAsync(Requests\removeRangeOnlineRequest $request) 
    {
        return $this->removeRangeOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation removeRangeOnlineAsyncWithHttpInfo
     *
     * Removes a range from the document.
     *
     * @param Requests\removeRangeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function removeRangeOnlineAsyncWithHttpInfo(Requests\removeRangeOnlineRequest $request) 
    {
        $returnType = 'RemoveRangeOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderDrawingObject
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderDrawingObject(Requests\renderDrawingObjectRequest $request)
    {
        try {
            list($response) = $this->renderDrawingObjectWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderDrawingObjectWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderDrawingObjectWithHttpInfo
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderDrawingObjectWithHttpInfo(Requests\renderDrawingObjectRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderDrawingObjectAsync
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderDrawingObjectAsync(Requests\renderDrawingObjectRequest $request) 
    {
        return $this->renderDrawingObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderDrawingObjectAsyncWithHttpInfo
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderDrawingObjectAsyncWithHttpInfo(Requests\renderDrawingObjectRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderDrawingObjectOnline
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderDrawingObjectOnline(Requests\renderDrawingObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->renderDrawingObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderDrawingObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderDrawingObjectOnlineWithHttpInfo
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderDrawingObjectOnlineWithHttpInfo(Requests\renderDrawingObjectOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderDrawingObjectOnlineAsync
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderDrawingObjectOnlineAsync(Requests\renderDrawingObjectOnlineRequest $request) 
    {
        return $this->renderDrawingObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderDrawingObjectOnlineAsyncWithHttpInfo
     *
     * Renders a DrawingObject to the specified format.
     *
     * @param Requests\renderDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderDrawingObjectOnlineAsyncWithHttpInfo(Requests\renderDrawingObjectOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderMathObject
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderMathObject(Requests\renderMathObjectRequest $request)
    {
        try {
            list($response) = $this->renderMathObjectWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderMathObjectWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderMathObjectWithHttpInfo
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderMathObjectWithHttpInfo(Requests\renderMathObjectRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderMathObjectAsync
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderMathObjectAsync(Requests\renderMathObjectRequest $request) 
    {
        return $this->renderMathObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderMathObjectAsyncWithHttpInfo
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderMathObjectAsyncWithHttpInfo(Requests\renderMathObjectRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderMathObjectOnline
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderMathObjectOnline(Requests\renderMathObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->renderMathObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderMathObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderMathObjectOnlineWithHttpInfo
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderMathObjectOnlineWithHttpInfo(Requests\renderMathObjectOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderMathObjectOnlineAsync
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderMathObjectOnlineAsync(Requests\renderMathObjectOnlineRequest $request) 
    {
        return $this->renderMathObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderMathObjectOnlineAsyncWithHttpInfo
     *
     * Renders an OfficeMath object to the specified format.
     *
     * @param Requests\renderMathObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderMathObjectOnlineAsyncWithHttpInfo(Requests\renderMathObjectOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderPage
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderPage(Requests\renderPageRequest $request)
    {
        try {
            list($response) = $this->renderPageWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderPageWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderPageWithHttpInfo
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderPageWithHttpInfo(Requests\renderPageRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderPageAsync
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderPageAsync(Requests\renderPageRequest $request) 
    {
        return $this->renderPageAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderPageAsyncWithHttpInfo
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderPageAsyncWithHttpInfo(Requests\renderPageRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderPageOnline
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderPageOnline(Requests\renderPageOnlineRequest $request)
    {
        try {
            list($response) = $this->renderPageOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderPageOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderPageOnlineWithHttpInfo
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderPageOnlineWithHttpInfo(Requests\renderPageOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderPageOnlineAsync
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderPageOnlineAsync(Requests\renderPageOnlineRequest $request) 
    {
        return $this->renderPageOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderPageOnlineAsyncWithHttpInfo
     *
     * Renders a page to the specified format.
     *
     * @param Requests\renderPageOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderPageOnlineAsyncWithHttpInfo(Requests\renderPageOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderParagraph
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderParagraph(Requests\renderParagraphRequest $request)
    {
        try {
            list($response) = $this->renderParagraphWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderParagraphWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderParagraphWithHttpInfo
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderParagraphWithHttpInfo(Requests\renderParagraphRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderParagraphAsync
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderParagraphAsync(Requests\renderParagraphRequest $request) 
    {
        return $this->renderParagraphAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderParagraphAsyncWithHttpInfo
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderParagraphAsyncWithHttpInfo(Requests\renderParagraphRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderParagraphOnline
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderParagraphOnline(Requests\renderParagraphOnlineRequest $request)
    {
        try {
            list($response) = $this->renderParagraphOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderParagraphOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderParagraphOnlineWithHttpInfo
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderParagraphOnlineWithHttpInfo(Requests\renderParagraphOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderParagraphOnlineAsync
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderParagraphOnlineAsync(Requests\renderParagraphOnlineRequest $request) 
    {
        return $this->renderParagraphOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderParagraphOnlineAsyncWithHttpInfo
     *
     * Renders a paragraph to the specified format.
     *
     * @param Requests\renderParagraphOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderParagraphOnlineAsyncWithHttpInfo(Requests\renderParagraphOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderTable
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderTable(Requests\renderTableRequest $request)
    {
        try {
            list($response) = $this->renderTableWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderTableWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderTableWithHttpInfo
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderTableWithHttpInfo(Requests\renderTableRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderTableAsync
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderTableAsync(Requests\renderTableRequest $request) 
    {
        return $this->renderTableAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderTableAsyncWithHttpInfo
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderTableAsyncWithHttpInfo(Requests\renderTableRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation renderTableOnline
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function renderTableOnline(Requests\renderTableOnlineRequest $request)
    {
        try {
            list($response) = $this->renderTableOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->renderTableOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation renderTableOnlineWithHttpInfo
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    private function renderTableOnlineWithHttpInfo(Requests\renderTableOnlineRequest $request)
    {
        $returnType = '\SplFileObject';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\SplFileObject', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation renderTableOnlineAsync
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderTableOnlineAsync(Requests\renderTableOnlineRequest $request) 
    {
        return $this->renderTableOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation renderTableOnlineAsyncWithHttpInfo
     *
     * Renders a table to the specified format.
     *
     * @param Requests\renderTableOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function renderTableOnlineAsyncWithHttpInfo(Requests\renderTableOnlineRequest $request) 
    {
        $returnType = '\SplFileObject';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation replaceText
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ReplaceTextResponse
     */
    public function replaceText(Requests\replaceTextRequest $request)
    {
        try {
            list($response) = $this->replaceTextWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->replaceTextWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation replaceTextWithHttpInfo
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ReplaceTextResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function replaceTextWithHttpInfo(Requests\replaceTextRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ReplaceTextResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ReplaceTextResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation replaceTextAsync
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTextAsync(Requests\replaceTextRequest $request) 
    {
        return $this->replaceTextAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation replaceTextAsyncWithHttpInfo
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function replaceTextAsyncWithHttpInfo(Requests\replaceTextRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ReplaceTextResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation replaceTextOnline
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return ReplaceTextOnlineResponse
     */
    public function replaceTextOnline(Requests\replaceTextOnlineRequest $request)
    {
        try {
            list($response) = $this->replaceTextOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->replaceTextOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation replaceTextOnlineWithHttpInfo
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of ReplaceTextOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function replaceTextOnlineWithHttpInfo(Requests\replaceTextOnlineRequest $request)
    {
        $returnType = 'ReplaceTextOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'ReplaceTextOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation replaceTextOnlineAsync
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTextOnlineAsync(Requests\replaceTextOnlineRequest $request) 
    {
        return $this->replaceTextOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation replaceTextOnlineAsyncWithHttpInfo
     *
     * Replaces text in the document.
     *
     * @param Requests\replaceTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function replaceTextOnlineAsyncWithHttpInfo(Requests\replaceTextOnlineRequest $request) 
    {
        $returnType = 'ReplaceTextOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation replaceWithText
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function replaceWithText(Requests\replaceWithTextRequest $request)
    {
        try {
            list($response) = $this->replaceWithTextWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->replaceWithTextWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation replaceWithTextWithHttpInfo
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function replaceWithTextWithHttpInfo(Requests\replaceWithTextRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation replaceWithTextAsync
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceWithTextAsync(Requests\replaceWithTextRequest $request) 
    {
        return $this->replaceWithTextAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation replaceWithTextAsyncWithHttpInfo
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function replaceWithTextAsyncWithHttpInfo(Requests\replaceWithTextRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation replaceWithTextOnline
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return ReplaceWithTextOnlineResponse
     */
    public function replaceWithTextOnline(Requests\replaceWithTextOnlineRequest $request)
    {
        try {
            list($response) = $this->replaceWithTextOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->replaceWithTextOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation replaceWithTextOnlineWithHttpInfo
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of ReplaceWithTextOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function replaceWithTextOnlineWithHttpInfo(Requests\replaceWithTextOnlineRequest $request)
    {
        $returnType = 'ReplaceWithTextOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'ReplaceWithTextOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation replaceWithTextOnlineAsync
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceWithTextOnlineAsync(Requests\replaceWithTextOnlineRequest $request) 
    {
        return $this->replaceWithTextOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation replaceWithTextOnlineAsyncWithHttpInfo
     *
     * Replaces a range with text in the document.
     *
     * @param Requests\replaceWithTextOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function replaceWithTextOnlineAsyncWithHttpInfo(Requests\replaceWithTextOnlineRequest $request) 
    {
        $returnType = 'ReplaceWithTextOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation resetCache
     *
     * Clears the font cache.
     *
     * @param Requests\resetCacheRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetCache(Requests\resetCacheRequest $request)
    {
        try {
    $this->resetCacheWithHttpInfo($request);
        }
        catch(RepeatRequestException $e) {
     		try {
    $this->resetCacheWithHttpInfo($request);
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation resetCacheWithHttpInfo
     *
     * Clears the font cache.
     *
     * @param Requests\resetCacheRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of void, HTTP status code, HTTP response headers (array of strings)
     */
    private function resetCacheWithHttpInfo(Requests\resetCacheRequest $request)
    {
        $returnType = 'void';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            throw $e;
        }
    }

    /*
     * Operation resetCacheAsync
     *
     * Clears the font cache.
     *
     * @param Requests\resetCacheRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetCacheAsync(Requests\resetCacheRequest $request) 
    {
        return $this->resetCacheAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation resetCacheAsyncWithHttpInfo
     *
     * Clears the font cache.
     *
     * @param Requests\resetCacheRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function resetCacheAsyncWithHttpInfo(Requests\resetCacheRequest $request) 
    {
        $returnType = 'void';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAs
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SaveResponse
     */
    public function saveAs(Requests\saveAsRequest $request)
    {
        try {
            list($response) = $this->saveAsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsWithHttpInfo(Requests\saveAsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsAsync
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsAsync(Requests\saveAsRequest $request) 
    {
        return $this->saveAsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsAsyncWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsAsyncWithHttpInfo(Requests\saveAsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAsOnline
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SaveAsOnlineResponse
     */
    public function saveAsOnline(Requests\saveAsOnlineRequest $request)
    {
        try {
            list($response) = $this->saveAsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsOnlineWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SaveAsOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsOnlineWithHttpInfo(Requests\saveAsOnlineRequest $request)
    {
        $returnType = 'SaveAsOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'SaveAsOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsOnlineAsync
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsOnlineAsync(Requests\saveAsOnlineRequest $request) 
    {
        return $this->saveAsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsOnlineAsyncWithHttpInfo
     *
     * Converts a document in cloud storage to the specified format.
     *
     * @param Requests\saveAsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsOnlineAsyncWithHttpInfo(Requests\saveAsOnlineRequest $request) 
    {
        $returnType = 'SaveAsOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAsRange
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function saveAsRange(Requests\saveAsRangeRequest $request)
    {
        try {
            list($response) = $this->saveAsRangeWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsRangeWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsRangeWithHttpInfo
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsRangeWithHttpInfo(Requests\saveAsRangeRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsRangeAsync
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsRangeAsync(Requests\saveAsRangeRequest $request) 
    {
        return $this->saveAsRangeAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsRangeAsyncWithHttpInfo
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsRangeAsyncWithHttpInfo(Requests\saveAsRangeRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAsRangeOnline
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SaveAsRangeOnlineResponse
     */
    public function saveAsRangeOnline(Requests\saveAsRangeOnlineRequest $request)
    {
        try {
            list($response) = $this->saveAsRangeOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsRangeOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsRangeOnlineWithHttpInfo
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SaveAsRangeOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsRangeOnlineWithHttpInfo(Requests\saveAsRangeOnlineRequest $request)
    {
        $returnType = 'SaveAsRangeOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'SaveAsRangeOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsRangeOnlineAsync
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsRangeOnlineAsync(Requests\saveAsRangeOnlineRequest $request) 
    {
        return $this->saveAsRangeOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsRangeOnlineAsyncWithHttpInfo
     *
     * Saves a range as a new document.
     *
     * @param Requests\saveAsRangeOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsRangeOnlineAsyncWithHttpInfo(Requests\saveAsRangeOnlineRequest $request) 
    {
        $returnType = 'SaveAsRangeOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAsTiff
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     * @deprecated This operation will be removed in the future.
     *
     * @param Requests\saveAsTiffRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SaveResponse
     */
    public function saveAsTiff(Requests\saveAsTiffRequest $request)
    {
        try {
            list($response) = $this->saveAsTiffWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsTiffWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsTiffWithHttpInfo
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SaveResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsTiffWithHttpInfo(Requests\saveAsTiffRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SaveResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsTiffAsync
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTiffAsync(Requests\saveAsTiffRequest $request) 
    {
        return $this->saveAsTiffAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsTiffAsyncWithHttpInfo
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsTiffAsyncWithHttpInfo(Requests\saveAsTiffRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SaveResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation saveAsTiffOnline
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     * @deprecated This operation will be removed in the future.
     *
     * @param Requests\saveAsTiffOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SaveAsTiffOnlineResponse
     */
    public function saveAsTiffOnline(Requests\saveAsTiffOnlineRequest $request)
    {
        try {
            list($response) = $this->saveAsTiffOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->saveAsTiffOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation saveAsTiffOnlineWithHttpInfo
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SaveAsTiffOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function saveAsTiffOnlineWithHttpInfo(Requests\saveAsTiffOnlineRequest $request)
    {
        $returnType = 'SaveAsTiffOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'SaveAsTiffOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation saveAsTiffOnlineAsync
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveAsTiffOnlineAsync(Requests\saveAsTiffOnlineRequest $request) 
    {
        return $this->saveAsTiffOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation saveAsTiffOnlineAsyncWithHttpInfo
     *
     * Converts a document in cloud storage to TIFF format using detailed conversion settings.
     *
     * @param Requests\saveAsTiffOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function saveAsTiffOnlineAsyncWithHttpInfo(Requests\saveAsTiffOnlineRequest $request) 
    {
        $returnType = 'SaveAsTiffOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation search
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SearchResponse
     */
    public function search(Requests\searchRequest $request)
    {
        try {
            list($response) = $this->searchWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->searchWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation searchWithHttpInfo
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function searchWithHttpInfo(Requests\searchRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SearchResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SearchResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation searchAsync
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync(Requests\searchRequest $request) 
    {
        return $this->searchAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation searchAsyncWithHttpInfo
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function searchAsyncWithHttpInfo(Requests\searchRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SearchResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation searchOnline
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SearchResponse
     */
    public function searchOnline(Requests\searchOnlineRequest $request)
    {
        try {
            list($response) = $this->searchOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->searchOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation searchOnlineWithHttpInfo
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function searchOnlineWithHttpInfo(Requests\searchOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SearchResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SearchResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation searchOnlineAsync
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchOnlineAsync(Requests\searchOnlineRequest $request) 
    {
        return $this->searchOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation searchOnlineAsyncWithHttpInfo
     *
     * Searches text, specified by the regular expression, in the document.
     *
     * @param Requests\searchOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function searchOnlineAsyncWithHttpInfo(Requests\searchOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SearchResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation signDocument
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SignatureCollectionResponse
     */
    public function signDocument(Requests\signDocumentRequest $request)
    {
        try {
            list($response) = $this->signDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->signDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation signDocumentWithHttpInfo
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SignatureCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function signDocumentWithHttpInfo(Requests\signDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SignatureCollectionResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation signDocumentAsync
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signDocumentAsync(Requests\signDocumentRequest $request) 
    {
        return $this->signDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation signDocumentAsyncWithHttpInfo
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function signDocumentAsyncWithHttpInfo(Requests\signDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SignatureCollectionResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation signDocumentOnline
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SignDocumentOnlineResponse
     */
    public function signDocumentOnline(Requests\signDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->signDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->signDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation signDocumentOnlineWithHttpInfo
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SignDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function signDocumentOnlineWithHttpInfo(Requests\signDocumentOnlineRequest $request)
    {
        $returnType = 'SignDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'SignDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation signDocumentOnlineAsync
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function signDocumentOnlineAsync(Requests\signDocumentOnlineRequest $request) 
    {
        return $this->signDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation signDocumentOnlineAsyncWithHttpInfo
     *
     * Signs the document with given certificate.
     *
     * @param Requests\signDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function signDocumentOnlineAsyncWithHttpInfo(Requests\signDocumentOnlineRequest $request) 
    {
        $returnType = 'SignDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation splitDocument
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SplitDocumentResponse
     */
    public function splitDocument(Requests\splitDocumentRequest $request)
    {
        try {
            list($response) = $this->splitDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->splitDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation splitDocumentWithHttpInfo
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SplitDocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function splitDocumentWithHttpInfo(Requests\splitDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SplitDocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SplitDocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation splitDocumentAsync
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitDocumentAsync(Requests\splitDocumentRequest $request) 
    {
        return $this->splitDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation splitDocumentAsyncWithHttpInfo
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function splitDocumentAsyncWithHttpInfo(Requests\splitDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SplitDocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation splitDocumentOnline
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SplitDocumentOnlineResponse
     */
    public function splitDocumentOnline(Requests\splitDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->splitDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->splitDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation splitDocumentOnlineWithHttpInfo
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SplitDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function splitDocumentOnlineWithHttpInfo(Requests\splitDocumentOnlineRequest $request)
    {
        $returnType = 'SplitDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'SplitDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation splitDocumentOnlineAsync
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function splitDocumentOnlineAsync(Requests\splitDocumentOnlineRequest $request) 
    {
        return $this->splitDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation splitDocumentOnlineAsyncWithHttpInfo
     *
     * Splits a document into parts and saves them in the specified format.
     *
     * @param Requests\splitDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function splitDocumentOnlineAsyncWithHttpInfo(Requests\splitDocumentOnlineRequest $request) 
    {
        $returnType = 'SplitDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation translateNodeId
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TranslateNodeIdResponse
     */
    public function translateNodeId(Requests\translateNodeIdRequest $request)
    {
        try {
            list($response) = $this->translateNodeIdWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->translateNodeIdWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation translateNodeIdWithHttpInfo
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TranslateNodeIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function translateNodeIdWithHttpInfo(Requests\translateNodeIdRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TranslateNodeIdResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TranslateNodeIdResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation translateNodeIdAsync
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translateNodeIdAsync(Requests\translateNodeIdRequest $request) 
    {
        return $this->translateNodeIdAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation translateNodeIdAsyncWithHttpInfo
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function translateNodeIdAsyncWithHttpInfo(Requests\translateNodeIdRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TranslateNodeIdResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation translateNodeIdOnline
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TranslateNodeIdResponse
     */
    public function translateNodeIdOnline(Requests\translateNodeIdOnlineRequest $request)
    {
        try {
            list($response) = $this->translateNodeIdOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->translateNodeIdOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation translateNodeIdOnlineWithHttpInfo
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TranslateNodeIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function translateNodeIdOnlineWithHttpInfo(Requests\translateNodeIdOnlineRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TranslateNodeIdResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TranslateNodeIdResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation translateNodeIdOnlineAsync
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function translateNodeIdOnlineAsync(Requests\translateNodeIdOnlineRequest $request) 
    {
        return $this->translateNodeIdOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation translateNodeIdOnlineAsyncWithHttpInfo
     *
     * Translate a node id to a node path.
     *
     * @param Requests\translateNodeIdOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function translateNodeIdOnlineAsyncWithHttpInfo(Requests\translateNodeIdOnlineRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TranslateNodeIdResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation unprotectDocument
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ProtectionDataResponse
     */
    public function unprotectDocument(Requests\unprotectDocumentRequest $request)
    {
        try {
            list($response) = $this->unprotectDocumentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->unprotectDocumentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation unprotectDocumentWithHttpInfo
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ProtectionDataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function unprotectDocumentWithHttpInfo(Requests\unprotectDocumentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ProtectionDataResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation unprotectDocumentAsync
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unprotectDocumentAsync(Requests\unprotectDocumentRequest $request) 
    {
        return $this->unprotectDocumentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation unprotectDocumentAsyncWithHttpInfo
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function unprotectDocumentAsyncWithHttpInfo(Requests\unprotectDocumentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ProtectionDataResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation unprotectDocumentOnline
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UnprotectDocumentOnlineResponse
     */
    public function unprotectDocumentOnline(Requests\unprotectDocumentOnlineRequest $request)
    {
        try {
            list($response) = $this->unprotectDocumentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->unprotectDocumentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation unprotectDocumentOnlineWithHttpInfo
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UnprotectDocumentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function unprotectDocumentOnlineWithHttpInfo(Requests\unprotectDocumentOnlineRequest $request)
    {
        $returnType = 'UnprotectDocumentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UnprotectDocumentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation unprotectDocumentOnlineAsync
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unprotectDocumentOnlineAsync(Requests\unprotectDocumentOnlineRequest $request) 
    {
        return $this->unprotectDocumentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation unprotectDocumentOnlineAsyncWithHttpInfo
     *
     * Removes protection from the document.
     *
     * @param Requests\unprotectDocumentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function unprotectDocumentOnlineAsyncWithHttpInfo(Requests\unprotectDocumentOnlineRequest $request) 
    {
        $returnType = 'UnprotectDocumentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateBookmark
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BookmarkResponse
     */
    public function updateBookmark(Requests\updateBookmarkRequest $request)
    {
        try {
            list($response) = $this->updateBookmarkWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateBookmarkWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateBookmarkWithHttpInfo
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BookmarkResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateBookmarkWithHttpInfo(Requests\updateBookmarkRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BookmarkResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateBookmarkAsync
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBookmarkAsync(Requests\updateBookmarkRequest $request) 
    {
        return $this->updateBookmarkAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateBookmarkAsyncWithHttpInfo
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateBookmarkAsyncWithHttpInfo(Requests\updateBookmarkRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BookmarkResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateBookmarkOnline
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateBookmarkOnlineResponse
     */
    public function updateBookmarkOnline(Requests\updateBookmarkOnlineRequest $request)
    {
        try {
            list($response) = $this->updateBookmarkOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateBookmarkOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateBookmarkOnlineWithHttpInfo
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateBookmarkOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateBookmarkOnlineWithHttpInfo(Requests\updateBookmarkOnlineRequest $request)
    {
        $returnType = 'UpdateBookmarkOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateBookmarkOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateBookmarkOnlineAsync
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBookmarkOnlineAsync(Requests\updateBookmarkOnlineRequest $request) 
    {
        return $this->updateBookmarkOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateBookmarkOnlineAsyncWithHttpInfo
     *
     * Updates a bookmark in the document.
     *
     * @param Requests\updateBookmarkOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateBookmarkOnlineAsyncWithHttpInfo(Requests\updateBookmarkOnlineRequest $request) 
    {
        $returnType = 'UpdateBookmarkOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateBorder
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\BorderResponse
     */
    public function updateBorder(Requests\updateBorderRequest $request)
    {
        try {
            list($response) = $this->updateBorderWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateBorderWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateBorderWithHttpInfo
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\BorderResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateBorderWithHttpInfo(Requests\updateBorderRequest $request)
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\BorderResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateBorderAsync
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBorderAsync(Requests\updateBorderRequest $request) 
    {
        return $this->updateBorderAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateBorderAsyncWithHttpInfo
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateBorderAsyncWithHttpInfo(Requests\updateBorderRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\BorderResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateBorderOnline
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateBorderOnlineResponse
     */
    public function updateBorderOnline(Requests\updateBorderOnlineRequest $request)
    {
        try {
            list($response) = $this->updateBorderOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateBorderOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateBorderOnlineWithHttpInfo
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateBorderOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateBorderOnlineWithHttpInfo(Requests\updateBorderOnlineRequest $request)
    {
        $returnType = 'UpdateBorderOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateBorderOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateBorderOnlineAsync
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBorderOnlineAsync(Requests\updateBorderOnlineRequest $request) 
    {
        return $this->updateBorderOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateBorderOnlineAsyncWithHttpInfo
     *
     * Updates a border in the document node.
     * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
     *
     * @param Requests\updateBorderOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateBorderOnlineAsyncWithHttpInfo(Requests\updateBorderOnlineRequest $request) 
    {
        $returnType = 'UpdateBorderOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateComment
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CommentResponse
     */
    public function updateComment(Requests\updateCommentRequest $request)
    {
        try {
            list($response) = $this->updateCommentWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateCommentWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateCommentWithHttpInfo
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CommentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateCommentWithHttpInfo(Requests\updateCommentRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CommentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateCommentAsync
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCommentAsync(Requests\updateCommentRequest $request) 
    {
        return $this->updateCommentAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateCommentAsyncWithHttpInfo
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateCommentAsyncWithHttpInfo(Requests\updateCommentRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CommentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateCommentOnline
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateCommentOnlineResponse
     */
    public function updateCommentOnline(Requests\updateCommentOnlineRequest $request)
    {
        try {
            list($response) = $this->updateCommentOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateCommentOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateCommentOnlineWithHttpInfo
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateCommentOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateCommentOnlineWithHttpInfo(Requests\updateCommentOnlineRequest $request)
    {
        $returnType = 'UpdateCommentOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateCommentOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateCommentOnlineAsync
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCommentOnlineAsync(Requests\updateCommentOnlineRequest $request) 
    {
        return $this->updateCommentOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateCommentOnlineAsyncWithHttpInfo
     *
     * Updates a comment in the document.
     *
     * @param Requests\updateCommentOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateCommentOnlineAsyncWithHttpInfo(Requests\updateCommentOnlineRequest $request) 
    {
        $returnType = 'UpdateCommentOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateCustomXmlPart
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\CustomXmlPartResponse
     */
    public function updateCustomXmlPart(Requests\updateCustomXmlPartRequest $request)
    {
        try {
            list($response) = $this->updateCustomXmlPartWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateCustomXmlPartWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateCustomXmlPartWithHttpInfo
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\CustomXmlPartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateCustomXmlPartWithHttpInfo(Requests\updateCustomXmlPartRequest $request)
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\CustomXmlPartResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateCustomXmlPartAsync
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomXmlPartAsync(Requests\updateCustomXmlPartRequest $request) 
    {
        return $this->updateCustomXmlPartAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateCustomXmlPartAsyncWithHttpInfo
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateCustomXmlPartAsyncWithHttpInfo(Requests\updateCustomXmlPartRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\CustomXmlPartResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateCustomXmlPartOnline
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateCustomXmlPartOnlineResponse
     */
    public function updateCustomXmlPartOnline(Requests\updateCustomXmlPartOnlineRequest $request)
    {
        try {
            list($response) = $this->updateCustomXmlPartOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateCustomXmlPartOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateCustomXmlPartOnlineWithHttpInfo
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateCustomXmlPartOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateCustomXmlPartOnlineWithHttpInfo(Requests\updateCustomXmlPartOnlineRequest $request)
    {
        $returnType = 'UpdateCustomXmlPartOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateCustomXmlPartOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateCustomXmlPartOnlineAsync
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCustomXmlPartOnlineAsync(Requests\updateCustomXmlPartOnlineRequest $request) 
    {
        return $this->updateCustomXmlPartOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateCustomXmlPartOnlineAsyncWithHttpInfo
     *
     * Updates the custom xml part in the document.
     *
     * @param Requests\updateCustomXmlPartOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateCustomXmlPartOnlineAsyncWithHttpInfo(Requests\updateCustomXmlPartOnlineRequest $request) 
    {
        $returnType = 'UpdateCustomXmlPartOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateDrawingObject
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DrawingObjectResponse
     */
    public function updateDrawingObject(Requests\updateDrawingObjectRequest $request)
    {
        try {
            list($response) = $this->updateDrawingObjectWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateDrawingObjectWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateDrawingObjectWithHttpInfo
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DrawingObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateDrawingObjectWithHttpInfo(Requests\updateDrawingObjectRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DrawingObjectResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateDrawingObjectAsync
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDrawingObjectAsync(Requests\updateDrawingObjectRequest $request) 
    {
        return $this->updateDrawingObjectAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateDrawingObjectAsyncWithHttpInfo
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateDrawingObjectAsyncWithHttpInfo(Requests\updateDrawingObjectRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DrawingObjectResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateDrawingObjectOnline
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateDrawingObjectOnlineResponse
     */
    public function updateDrawingObjectOnline(Requests\updateDrawingObjectOnlineRequest $request)
    {
        try {
            list($response) = $this->updateDrawingObjectOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateDrawingObjectOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateDrawingObjectOnlineWithHttpInfo
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateDrawingObjectOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateDrawingObjectOnlineWithHttpInfo(Requests\updateDrawingObjectOnlineRequest $request)
    {
        $returnType = 'UpdateDrawingObjectOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateDrawingObjectOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateDrawingObjectOnlineAsync
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDrawingObjectOnlineAsync(Requests\updateDrawingObjectOnlineRequest $request) 
    {
        return $this->updateDrawingObjectOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateDrawingObjectOnlineAsyncWithHttpInfo
     *
     * Updates a DrawingObject in the document node.
     *
     * @param Requests\updateDrawingObjectOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateDrawingObjectOnlineAsyncWithHttpInfo(Requests\updateDrawingObjectOnlineRequest $request) 
    {
        $returnType = 'UpdateDrawingObjectOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateField
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FieldResponse
     */
    public function updateField(Requests\updateFieldRequest $request)
    {
        try {
            list($response) = $this->updateFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFieldWithHttpInfo
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFieldWithHttpInfo(Requests\updateFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFieldAsync
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldAsync(Requests\updateFieldRequest $request) 
    {
        return $this->updateFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFieldAsyncWithHttpInfo
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFieldAsyncWithHttpInfo(Requests\updateFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFieldOnline
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateFieldOnlineResponse
     */
    public function updateFieldOnline(Requests\updateFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->updateFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFieldOnlineWithHttpInfo
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateFieldOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFieldOnlineWithHttpInfo(Requests\updateFieldOnlineRequest $request)
    {
        $returnType = 'UpdateFieldOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateFieldOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFieldOnlineAsync
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldOnlineAsync(Requests\updateFieldOnlineRequest $request) 
    {
        return $this->updateFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFieldOnlineAsyncWithHttpInfo
     *
     * Updates a field in the document node.
     *
     * @param Requests\updateFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFieldOnlineAsyncWithHttpInfo(Requests\updateFieldOnlineRequest $request) 
    {
        $returnType = 'UpdateFieldOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFields
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\DocumentResponse
     */
    public function updateFields(Requests\updateFieldsRequest $request)
    {
        try {
            list($response) = $this->updateFieldsWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFieldsWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFieldsWithHttpInfo
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\DocumentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFieldsWithHttpInfo(Requests\updateFieldsRequest $request)
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\DocumentResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFieldsAsync
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldsAsync(Requests\updateFieldsRequest $request) 
    {
        return $this->updateFieldsAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFieldsAsyncWithHttpInfo
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFieldsAsyncWithHttpInfo(Requests\updateFieldsRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\DocumentResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFieldsOnline
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateFieldsOnlineResponse
     */
    public function updateFieldsOnline(Requests\updateFieldsOnlineRequest $request)
    {
        try {
            list($response) = $this->updateFieldsOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFieldsOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFieldsOnlineWithHttpInfo
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateFieldsOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFieldsOnlineWithHttpInfo(Requests\updateFieldsOnlineRequest $request)
    {
        $returnType = 'UpdateFieldsOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateFieldsOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFieldsOnlineAsync
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldsOnlineAsync(Requests\updateFieldsOnlineRequest $request) 
    {
        return $this->updateFieldsOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFieldsOnlineAsyncWithHttpInfo
     *
     * Reevaluates field values in the document.
     *
     * @param Requests\updateFieldsOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFieldsOnlineAsyncWithHttpInfo(Requests\updateFieldsOnlineRequest $request) 
    {
        $returnType = 'UpdateFieldsOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFootnote
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FootnoteResponse
     */
    public function updateFootnote(Requests\updateFootnoteRequest $request)
    {
        try {
            list($response) = $this->updateFootnoteWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFootnoteWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFootnoteWithHttpInfo
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FootnoteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFootnoteWithHttpInfo(Requests\updateFootnoteRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FootnoteResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFootnoteAsync
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFootnoteAsync(Requests\updateFootnoteRequest $request) 
    {
        return $this->updateFootnoteAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFootnoteAsyncWithHttpInfo
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFootnoteAsyncWithHttpInfo(Requests\updateFootnoteRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FootnoteResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFootnoteOnline
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateFootnoteOnlineResponse
     */
    public function updateFootnoteOnline(Requests\updateFootnoteOnlineRequest $request)
    {
        try {
            list($response) = $this->updateFootnoteOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFootnoteOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFootnoteOnlineWithHttpInfo
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateFootnoteOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFootnoteOnlineWithHttpInfo(Requests\updateFootnoteOnlineRequest $request)
    {
        $returnType = 'UpdateFootnoteOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateFootnoteOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFootnoteOnlineAsync
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFootnoteOnlineAsync(Requests\updateFootnoteOnlineRequest $request) 
    {
        return $this->updateFootnoteOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFootnoteOnlineAsyncWithHttpInfo
     *
     * Updates a footnote in the document node.
     *
     * @param Requests\updateFootnoteOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFootnoteOnlineAsyncWithHttpInfo(Requests\updateFootnoteOnlineRequest $request) 
    {
        $returnType = 'UpdateFootnoteOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFormField
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FormFieldResponse
     */
    public function updateFormField(Requests\updateFormFieldRequest $request)
    {
        try {
            list($response) = $this->updateFormFieldWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFormFieldWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFormFieldWithHttpInfo
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FormFieldResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFormFieldWithHttpInfo(Requests\updateFormFieldRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FormFieldResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFormFieldAsync
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFormFieldAsync(Requests\updateFormFieldRequest $request) 
    {
        return $this->updateFormFieldAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFormFieldAsyncWithHttpInfo
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFormFieldAsyncWithHttpInfo(Requests\updateFormFieldRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FormFieldResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateFormFieldOnline
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateFormFieldOnlineResponse
     */
    public function updateFormFieldOnline(Requests\updateFormFieldOnlineRequest $request)
    {
        try {
            list($response) = $this->updateFormFieldOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateFormFieldOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateFormFieldOnlineWithHttpInfo
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateFormFieldOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateFormFieldOnlineWithHttpInfo(Requests\updateFormFieldOnlineRequest $request)
    {
        $returnType = 'UpdateFormFieldOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateFormFieldOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateFormFieldOnlineAsync
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFormFieldOnlineAsync(Requests\updateFormFieldOnlineRequest $request) 
    {
        return $this->updateFormFieldOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateFormFieldOnlineAsyncWithHttpInfo
     *
     * Updates a form field in the document node.
     *
     * @param Requests\updateFormFieldOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateFormFieldOnlineAsyncWithHttpInfo(Requests\updateFormFieldOnlineRequest $request) 
    {
        $returnType = 'UpdateFormFieldOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateList
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListResponse
     */
    public function updateList(Requests\updateListRequest $request)
    {
        try {
            list($response) = $this->updateListWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateListWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateListWithHttpInfo
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateListWithHttpInfo(Requests\updateListRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateListAsync
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListAsync(Requests\updateListRequest $request) 
    {
        return $this->updateListAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateListAsyncWithHttpInfo
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateListAsyncWithHttpInfo(Requests\updateListRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateListLevel
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ListResponse
     */
    public function updateListLevel(Requests\updateListLevelRequest $request)
    {
        try {
            list($response) = $this->updateListLevelWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateListLevelWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateListLevelWithHttpInfo
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateListLevelWithHttpInfo(Requests\updateListLevelRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ListResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateListLevelAsync
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListLevelAsync(Requests\updateListLevelRequest $request) 
    {
        return $this->updateListLevelAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateListLevelAsyncWithHttpInfo
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateListLevelAsyncWithHttpInfo(Requests\updateListLevelRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ListResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateListLevelOnline
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateListLevelOnlineResponse
     */
    public function updateListLevelOnline(Requests\updateListLevelOnlineRequest $request)
    {
        try {
            list($response) = $this->updateListLevelOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateListLevelOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateListLevelOnlineWithHttpInfo
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateListLevelOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateListLevelOnlineWithHttpInfo(Requests\updateListLevelOnlineRequest $request)
    {
        $returnType = 'UpdateListLevelOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateListLevelOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateListLevelOnlineAsync
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListLevelOnlineAsync(Requests\updateListLevelOnlineRequest $request) 
    {
        return $this->updateListLevelOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateListLevelOnlineAsyncWithHttpInfo
     *
     * Updates the level of a List element in the document.
     *
     * @param Requests\updateListLevelOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateListLevelOnlineAsyncWithHttpInfo(Requests\updateListLevelOnlineRequest $request) 
    {
        $returnType = 'UpdateListLevelOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateListOnline
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateListOnlineResponse
     */
    public function updateListOnline(Requests\updateListOnlineRequest $request)
    {
        try {
            list($response) = $this->updateListOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateListOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateListOnlineWithHttpInfo
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateListOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateListOnlineWithHttpInfo(Requests\updateListOnlineRequest $request)
    {
        $returnType = 'UpdateListOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateListOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateListOnlineAsync
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateListOnlineAsync(Requests\updateListOnlineRequest $request) 
    {
        return $this->updateListOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateListOnlineAsyncWithHttpInfo
     *
     * Updates a list in the document.
     *
     * @param Requests\updateListOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateListOnlineAsyncWithHttpInfo(Requests\updateListOnlineRequest $request) 
    {
        $returnType = 'UpdateListOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateParagraphFormat
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphFormatResponse
     */
    public function updateParagraphFormat(Requests\updateParagraphFormatRequest $request)
    {
        try {
            list($response) = $this->updateParagraphFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateParagraphFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateParagraphFormatWithHttpInfo
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateParagraphFormatWithHttpInfo(Requests\updateParagraphFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateParagraphFormatAsync
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParagraphFormatAsync(Requests\updateParagraphFormatRequest $request) 
    {
        return $this->updateParagraphFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateParagraphFormatAsyncWithHttpInfo
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateParagraphFormatAsyncWithHttpInfo(Requests\updateParagraphFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateParagraphFormatOnline
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateParagraphFormatOnlineResponse
     */
    public function updateParagraphFormatOnline(Requests\updateParagraphFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->updateParagraphFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateParagraphFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateParagraphFormatOnlineWithHttpInfo
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateParagraphFormatOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateParagraphFormatOnlineWithHttpInfo(Requests\updateParagraphFormatOnlineRequest $request)
    {
        $returnType = 'UpdateParagraphFormatOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateParagraphFormatOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateParagraphFormatOnlineAsync
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParagraphFormatOnlineAsync(Requests\updateParagraphFormatOnlineRequest $request) 
    {
        return $this->updateParagraphFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateParagraphFormatOnlineAsyncWithHttpInfo
     *
     * Updates the formatting properties of a paragraph in the document node.
     *
     * @param Requests\updateParagraphFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateParagraphFormatOnlineAsyncWithHttpInfo(Requests\updateParagraphFormatOnlineRequest $request) 
    {
        $returnType = 'UpdateParagraphFormatOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateParagraphListFormat
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\ParagraphListFormatResponse
     */
    public function updateParagraphListFormat(Requests\updateParagraphListFormatRequest $request)
    {
        try {
            list($response) = $this->updateParagraphListFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateParagraphListFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateParagraphListFormatWithHttpInfo
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\ParagraphListFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateParagraphListFormatWithHttpInfo(Requests\updateParagraphListFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\ParagraphListFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateParagraphListFormatAsync
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParagraphListFormatAsync(Requests\updateParagraphListFormatRequest $request) 
    {
        return $this->updateParagraphListFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateParagraphListFormatAsyncWithHttpInfo
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateParagraphListFormatAsyncWithHttpInfo(Requests\updateParagraphListFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\ParagraphListFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateParagraphListFormatOnline
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateParagraphListFormatOnlineResponse
     */
    public function updateParagraphListFormatOnline(Requests\updateParagraphListFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->updateParagraphListFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateParagraphListFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateParagraphListFormatOnlineWithHttpInfo
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateParagraphListFormatOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateParagraphListFormatOnlineWithHttpInfo(Requests\updateParagraphListFormatOnlineRequest $request)
    {
        $returnType = 'UpdateParagraphListFormatOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateParagraphListFormatOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateParagraphListFormatOnlineAsync
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateParagraphListFormatOnlineAsync(Requests\updateParagraphListFormatOnlineRequest $request) 
    {
        return $this->updateParagraphListFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateParagraphListFormatOnlineAsyncWithHttpInfo
     *
     * Updates the formatting properties of a paragraph list in the document node.
     *
     * @param Requests\updateParagraphListFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateParagraphListFormatOnlineAsyncWithHttpInfo(Requests\updateParagraphListFormatOnlineRequest $request) 
    {
        $returnType = 'UpdateParagraphListFormatOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateRun
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\RunResponse
     */
    public function updateRun(Requests\updateRunRequest $request)
    {
        try {
            list($response) = $this->updateRunWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateRunWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateRunWithHttpInfo
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\RunResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateRunWithHttpInfo(Requests\updateRunRequest $request)
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\RunResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateRunAsync
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRunAsync(Requests\updateRunRequest $request) 
    {
        return $this->updateRunAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateRunAsyncWithHttpInfo
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateRunAsyncWithHttpInfo(Requests\updateRunRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\RunResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateRunFont
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FontResponse
     */
    public function updateRunFont(Requests\updateRunFontRequest $request)
    {
        try {
            list($response) = $this->updateRunFontWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateRunFontWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateRunFontWithHttpInfo
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FontResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateRunFontWithHttpInfo(Requests\updateRunFontRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FontResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateRunFontAsync
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRunFontAsync(Requests\updateRunFontRequest $request) 
    {
        return $this->updateRunFontAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateRunFontAsyncWithHttpInfo
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateRunFontAsyncWithHttpInfo(Requests\updateRunFontRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FontResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateRunFontOnline
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateRunFontOnlineResponse
     */
    public function updateRunFontOnline(Requests\updateRunFontOnlineRequest $request)
    {
        try {
            list($response) = $this->updateRunFontOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateRunFontOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateRunFontOnlineWithHttpInfo
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateRunFontOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateRunFontOnlineWithHttpInfo(Requests\updateRunFontOnlineRequest $request)
    {
        $returnType = 'UpdateRunFontOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateRunFontOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateRunFontOnlineAsync
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRunFontOnlineAsync(Requests\updateRunFontOnlineRequest $request) 
    {
        return $this->updateRunFontOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateRunFontOnlineAsyncWithHttpInfo
     *
     * Updates the font properties of a Run object in the paragraph.
     *
     * @param Requests\updateRunFontOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateRunFontOnlineAsyncWithHttpInfo(Requests\updateRunFontOnlineRequest $request) 
    {
        $returnType = 'UpdateRunFontOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateRunOnline
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateRunOnlineResponse
     */
    public function updateRunOnline(Requests\updateRunOnlineRequest $request)
    {
        try {
            list($response) = $this->updateRunOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateRunOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateRunOnlineWithHttpInfo
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateRunOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateRunOnlineWithHttpInfo(Requests\updateRunOnlineRequest $request)
    {
        $returnType = 'UpdateRunOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateRunOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateRunOnlineAsync
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRunOnlineAsync(Requests\updateRunOnlineRequest $request) 
    {
        return $this->updateRunOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateRunOnlineAsyncWithHttpInfo
     *
     * Updates a Run object in the paragraph.
     *
     * @param Requests\updateRunOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateRunOnlineAsyncWithHttpInfo(Requests\updateRunOnlineRequest $request) 
    {
        $returnType = 'UpdateRunOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateSectionPageSetup
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\SectionPageSetupResponse
     */
    public function updateSectionPageSetup(Requests\updateSectionPageSetupRequest $request)
    {
        try {
            list($response) = $this->updateSectionPageSetupWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateSectionPageSetupWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateSectionPageSetupWithHttpInfo
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\SectionPageSetupResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateSectionPageSetupWithHttpInfo(Requests\updateSectionPageSetupRequest $request)
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\SectionPageSetupResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateSectionPageSetupAsync
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSectionPageSetupAsync(Requests\updateSectionPageSetupRequest $request) 
    {
        return $this->updateSectionPageSetupAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateSectionPageSetupAsyncWithHttpInfo
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateSectionPageSetupAsyncWithHttpInfo(Requests\updateSectionPageSetupRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\SectionPageSetupResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateSectionPageSetupOnline
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateSectionPageSetupOnlineResponse
     */
    public function updateSectionPageSetupOnline(Requests\updateSectionPageSetupOnlineRequest $request)
    {
        try {
            list($response) = $this->updateSectionPageSetupOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateSectionPageSetupOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateSectionPageSetupOnlineWithHttpInfo
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateSectionPageSetupOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateSectionPageSetupOnlineWithHttpInfo(Requests\updateSectionPageSetupOnlineRequest $request)
    {
        $returnType = 'UpdateSectionPageSetupOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateSectionPageSetupOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateSectionPageSetupOnlineAsync
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSectionPageSetupOnlineAsync(Requests\updateSectionPageSetupOnlineRequest $request) 
    {
        return $this->updateSectionPageSetupOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateSectionPageSetupOnlineAsyncWithHttpInfo
     *
     * Updates the page setup of a section in the document.
     *
     * @param Requests\updateSectionPageSetupOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateSectionPageSetupOnlineAsyncWithHttpInfo(Requests\updateSectionPageSetupOnlineRequest $request) 
    {
        $returnType = 'UpdateSectionPageSetupOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateStructuredDocumentTag
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StructuredDocumentTagResponse
     */
    public function updateStructuredDocumentTag(Requests\updateStructuredDocumentTagRequest $request)
    {
        try {
            list($response) = $this->updateStructuredDocumentTagWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateStructuredDocumentTagWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateStructuredDocumentTagWithHttpInfo
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StructuredDocumentTagResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateStructuredDocumentTagWithHttpInfo(Requests\updateStructuredDocumentTagRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StructuredDocumentTagResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateStructuredDocumentTagAsync
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStructuredDocumentTagAsync(Requests\updateStructuredDocumentTagRequest $request) 
    {
        return $this->updateStructuredDocumentTagAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateStructuredDocumentTagAsyncWithHttpInfo
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateStructuredDocumentTagAsyncWithHttpInfo(Requests\updateStructuredDocumentTagRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StructuredDocumentTagResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateStructuredDocumentTagOnline
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateStructuredDocumentTagOnlineResponse
     */
    public function updateStructuredDocumentTagOnline(Requests\updateStructuredDocumentTagOnlineRequest $request)
    {
        try {
            list($response) = $this->updateStructuredDocumentTagOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateStructuredDocumentTagOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateStructuredDocumentTagOnlineWithHttpInfo
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateStructuredDocumentTagOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateStructuredDocumentTagOnlineWithHttpInfo(Requests\updateStructuredDocumentTagOnlineRequest $request)
    {
        $returnType = 'UpdateStructuredDocumentTagOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateStructuredDocumentTagOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateStructuredDocumentTagOnlineAsync
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStructuredDocumentTagOnlineAsync(Requests\updateStructuredDocumentTagOnlineRequest $request) 
    {
        return $this->updateStructuredDocumentTagOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateStructuredDocumentTagOnlineAsyncWithHttpInfo
     *
     * Updates a StructuredDocumentTag (SDT) in the document node.
     *
     * @param Requests\updateStructuredDocumentTagOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateStructuredDocumentTagOnlineAsyncWithHttpInfo(Requests\updateStructuredDocumentTagOnlineRequest $request) 
    {
        $returnType = 'UpdateStructuredDocumentTagOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateStyle
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\StyleResponse
     */
    public function updateStyle(Requests\updateStyleRequest $request)
    {
        try {
            list($response) = $this->updateStyleWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateStyleWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateStyleWithHttpInfo
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\StyleResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateStyleWithHttpInfo(Requests\updateStyleRequest $request)
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\StyleResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateStyleAsync
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStyleAsync(Requests\updateStyleRequest $request) 
    {
        return $this->updateStyleAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateStyleAsyncWithHttpInfo
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateStyleAsyncWithHttpInfo(Requests\updateStyleRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\StyleResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateStyleOnline
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateStyleOnlineResponse
     */
    public function updateStyleOnline(Requests\updateStyleOnlineRequest $request)
    {
        try {
            list($response) = $this->updateStyleOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateStyleOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateStyleOnlineWithHttpInfo
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateStyleOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateStyleOnlineWithHttpInfo(Requests\updateStyleOnlineRequest $request)
    {
        $returnType = 'UpdateStyleOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateStyleOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateStyleOnlineAsync
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStyleOnlineAsync(Requests\updateStyleOnlineRequest $request) 
    {
        return $this->updateStyleOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateStyleOnlineAsyncWithHttpInfo
     *
     * Updates a style in the document.
     *
     * @param Requests\updateStyleOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateStyleOnlineAsyncWithHttpInfo(Requests\updateStyleOnlineRequest $request) 
    {
        $returnType = 'UpdateStyleOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTableCellFormat
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableCellFormatResponse
     */
    public function updateTableCellFormat(Requests\updateTableCellFormatRequest $request)
    {
        try {
            list($response) = $this->updateTableCellFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTableCellFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTableCellFormatWithHttpInfo
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableCellFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTableCellFormatWithHttpInfo(Requests\updateTableCellFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableCellFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTableCellFormatAsync
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableCellFormatAsync(Requests\updateTableCellFormatRequest $request) 
    {
        return $this->updateTableCellFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTableCellFormatAsyncWithHttpInfo
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTableCellFormatAsyncWithHttpInfo(Requests\updateTableCellFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableCellFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTableCellFormatOnline
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateTableCellFormatOnlineResponse
     */
    public function updateTableCellFormatOnline(Requests\updateTableCellFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->updateTableCellFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTableCellFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTableCellFormatOnlineWithHttpInfo
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateTableCellFormatOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTableCellFormatOnlineWithHttpInfo(Requests\updateTableCellFormatOnlineRequest $request)
    {
        $returnType = 'UpdateTableCellFormatOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateTableCellFormatOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTableCellFormatOnlineAsync
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableCellFormatOnlineAsync(Requests\updateTableCellFormatOnlineRequest $request) 
    {
        return $this->updateTableCellFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTableCellFormatOnlineAsyncWithHttpInfo
     *
     * Updates the formatting properties of a cell in the table row.
     *
     * @param Requests\updateTableCellFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTableCellFormatOnlineAsyncWithHttpInfo(Requests\updateTableCellFormatOnlineRequest $request) 
    {
        $returnType = 'UpdateTableCellFormatOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTableProperties
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TablePropertiesResponse
     */
    public function updateTableProperties(Requests\updateTablePropertiesRequest $request)
    {
        try {
            list($response) = $this->updateTablePropertiesWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTablePropertiesWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTablePropertiesWithHttpInfo
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TablePropertiesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTablePropertiesWithHttpInfo(Requests\updateTablePropertiesRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TablePropertiesResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTablePropertiesAsync
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTablePropertiesAsync(Requests\updateTablePropertiesRequest $request) 
    {
        return $this->updateTablePropertiesAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTablePropertiesAsyncWithHttpInfo
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTablePropertiesAsyncWithHttpInfo(Requests\updateTablePropertiesRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TablePropertiesResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTablePropertiesOnline
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateTablePropertiesOnlineResponse
     */
    public function updateTablePropertiesOnline(Requests\updateTablePropertiesOnlineRequest $request)
    {
        try {
            list($response) = $this->updateTablePropertiesOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTablePropertiesOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTablePropertiesOnlineWithHttpInfo
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateTablePropertiesOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTablePropertiesOnlineWithHttpInfo(Requests\updateTablePropertiesOnlineRequest $request)
    {
        $returnType = 'UpdateTablePropertiesOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateTablePropertiesOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTablePropertiesOnlineAsync
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTablePropertiesOnlineAsync(Requests\updateTablePropertiesOnlineRequest $request) 
    {
        return $this->updateTablePropertiesOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTablePropertiesOnlineAsyncWithHttpInfo
     *
     * Updates properties of a table in the document node.
     *
     * @param Requests\updateTablePropertiesOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTablePropertiesOnlineAsyncWithHttpInfo(Requests\updateTablePropertiesOnlineRequest $request) 
    {
        $returnType = 'UpdateTablePropertiesOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTableRowFormat
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\TableRowFormatResponse
     */
    public function updateTableRowFormat(Requests\updateTableRowFormatRequest $request)
    {
        try {
            list($response) = $this->updateTableRowFormatWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTableRowFormatWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTableRowFormatWithHttpInfo
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\TableRowFormatResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTableRowFormatWithHttpInfo(Requests\updateTableRowFormatRequest $request)
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\TableRowFormatResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTableRowFormatAsync
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableRowFormatAsync(Requests\updateTableRowFormatRequest $request) 
    {
        return $this->updateTableRowFormatAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTableRowFormatAsyncWithHttpInfo
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTableRowFormatAsyncWithHttpInfo(Requests\updateTableRowFormatRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\TableRowFormatResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation updateTableRowFormatOnline
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return UpdateTableRowFormatOnlineResponse
     */
    public function updateTableRowFormatOnline(Requests\updateTableRowFormatOnlineRequest $request)
    {
        try {
            list($response) = $this->updateTableRowFormatOnlineWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->updateTableRowFormatOnlineWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation updateTableRowFormatOnlineWithHttpInfo
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of UpdateTableRowFormatOnlineResponse, HTTP status code, HTTP response headers (array of strings)
     */
    private function updateTableRowFormatOnlineWithHttpInfo(Requests\updateTableRowFormatOnlineRequest $request)
    {
        $returnType = 'UpdateTableRowFormatOnlineResponse';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $resp = $request->deserializeResponse($response);
            return [
                    $resp,
                    $response->getStatusCode(),
                    $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), 'UpdateTableRowFormatOnlineResponse', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation updateTableRowFormatOnlineAsync
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableRowFormatOnlineAsync(Requests\updateTableRowFormatOnlineRequest $request) 
    {
        return $this->updateTableRowFormatOnlineAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation updateTableRowFormatOnlineAsyncWithHttpInfo
     *
     * Updates the formatting properties of a table row.
     *
     * @param Requests\updateTableRowFormatOnlineRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function updateTableRowFormatOnlineAsyncWithHttpInfo(Requests\updateTableRowFormatOnlineRequest $request) 
    {
        $returnType = 'UpdateTableRowFormatOnlineResponse';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation uploadFile
     *
     * Upload file.
     *
     * @param Requests\uploadFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Aspose\Words\Model\FilesUploadResult
     */
    public function uploadFile(Requests\uploadFileRequest $request)
    {
        try {
            list($response) = $this->uploadFileWithHttpInfo($request);
            return $response;
        }
        catch(RepeatRequestException $e) {
     		try {
            	list($response) = $this->uploadFileWithHttpInfo($request);
            	return $response;
        	}
        	catch(RepeatRequestException $e) {
            	throw new ApiException('Authorization failed', $e->getCode(), null, null);
        	} 
        } 
    }

    /*
     * Operation uploadFileWithHttpInfo
     *
     * Upload file.
     *
     * @param Requests\uploadFileRequest $request is a request object for operation
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Aspose\Words\Model\FilesUploadResult, HTTP status code, HTTP response headers (array of strings)
     */
    private function uploadFileWithHttpInfo(Requests\uploadFileRequest $request)
    {
        $returnType = '\Aspose\Words\Model\FilesUploadResult';
        $this->_checkAuthToken();
        $req = $request->createRequest($this->config);

        try {
            $options = $this->_createHttpClientOption();
            try {
                $response = $this->client->send($req, $options);
            } catch (RequestException $e) {
                if ($e->getCode() == 401) {
                    $this->_requestToken();
                    throw new RepeatRequestException("Request must be retried", 401, null, null);
                }
                else if ($e->getCode() < 200 || $e->getCode() > 299) {
                    throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $req->getUri()), $e->getCode(), null, null);
                }
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $statusCode, $req->getUri()), $statusCode, $response->getHeaders(), $response->getBody());
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            if ($this->config->getDebug()) {
                $this->_writeResponseLog($statusCode, $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                $response->getStatusCode(),
                $response->getHeaders()
            ];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            case 200:
                    $data = ObjectSerializer::deserialize($e->getResponseBody(), '\Aspose\Words\Model\FilesUploadResult', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                break;
            }
            throw $e;
        }
    }

    /*
     * Operation uploadFileAsync
     *
     * Upload file.
     *
     * @param Requests\uploadFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync(Requests\uploadFileRequest $request) 
    {
        return $this->uploadFileAsyncWithHttpInfo($request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /*
     * Operation uploadFileAsyncWithHttpInfo
     *
     * Upload file.
     *
     * @param Requests\uploadFileRequest $request is a request object for operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function uploadFileAsyncWithHttpInfo(Requests\uploadFileRequest $request) 
    {
        $returnType = '\Aspose\Words\Model\FilesUploadResult';
        $request = $request->createRequest($this->config);

        return $this->client
            ->sendAsync($request, $this->_createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject' || $returnType === 'FILES_COLLECTION') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    if ($this->config->getDebug()) {
                        $this->_writeResponseLog($response->getStatusCode(), $response->getHeaders(), ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()));
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, $response->getHeaders()),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {        
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();

                    if ($exception instanceof RepeatRequestException) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }

                    throw new ApiException(
                        sprintf('[%d] Error connecting to the API (%s)', $statusCode, $exception->getRequest()->getUri()), $statusCode, $response->getHeaders(), $response->getBody()
                    );
                }
            );
    }

    /*
     * Operation bacth requests
     *
     * @param array of requests
     * @param display intermediate results or not
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of response objects
     */
    public function batch($requests, $displayIntermediateResults = true)
    {
        try {
            return $this->batchWithHttpInfo($requests, $displayIntermediateResults);
        }
        catch(RepeatRequestException $e) {
            return $this->batchWithHttpInfo($requests, $displayIntermediateResults);
        }
    }

    /*
     * Operation batch requests
     *
     * @param array of requests
     * @param display intermediate results or not
     *
     * @throws \Aspose\Words\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of response objects
     */
    private function batchWithHttpInfo($requests, $displayIntermediateResults = true)
    {
        return $this->batchAsyncWithHttpInfo($requests, $displayIntermediateResults)->wait();
    }

    /*
     * Async operation batch requests
     *
     * @param array of requests
     * @param display intermediate results or not
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAsync($requests, $displayIntermediateResults = true) 
    {
        return $this->batchAsyncWithHttpInfo($requests, $displayIntermediateResults)
            ->then(
                function ($response) {
                    return $response;
                }
            );
    }

    /*
     * data encrypting
     *
     * @param data string to encrypt
     * @param display intermediate results or not
     *
     * @throws \InvalidArgumentException
     * @return encrypted data as base64 encoded string
     */
    public function encrypt($data)
    {
        if (!isSet( $data ) || empty( $data ) )
        {
            return $data;
        }

        if (!isset($this->rsaKey))
        {
            $exponent = (null !== $this->config->getExponent()) &&  !empty($this->config->getExponent()) ? $this->config->getExponent() : null;
            $modulus = (null !== $this->config->getModulus()) &&  !empty($this->config->getModulus()) ? $this->config->getModulus() : null;

            if ( !isset($modulus) || !isset($exponent)  )
            {
                $response = $this->getPublicKey(new Requests\GetPublicKeyRequest());
                $exponent = $response->getExponent();
                $modulus = $response->getModulus();
            }

            $this->rsaKey = PublicKeyLoader::load([
                'e' => new BigInteger(base64_decode($exponent), 256),
                'n' => new BigInteger(base64_decode($modulus), 256)
            ]);
        }

        return base64_encode(RSA::loadPublicKey($this->rsaKey)->withPadding(RSA::ENCRYPTION_PKCS1)->encrypt($data));
    }

    /*
     * Async operation batch requests
     *
     * @param array of requests
     * @param display intermediate results or not
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function batchAsyncWithHttpInfo($requests, $displayIntermediateResults = true) 
    {
        if (count($requests) == 0)
        {
            return array();
        }

        $options = $this->_createHttpClientOption();
        $this->_checkAuthToken();

        $multipartContents = [];
        $idToRequestMap = array();
        foreach ($requests as $request)
        {
            $reqId = $request->getRequestId();
            $partData = ObjectSerializer::createBatchPart($this->config, $request);
            $multipartContents[] = [
                'name' => sha1(uniqid('', true)),
                'filename' => sha1(uniqid('', true)),
                'contents' => $partData,
                'headers' => ['Content-Type' => 'application/http; msgtype=request']
            ];
            $idToRequestMap[$reqId] = $request;
        }

        $headers = [];
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        if ($this->config->getUserAgent()) {
            $headers['x-aspose-client'] = $this->config->getUserAgent();
        }

        $headers['x-aspose-client-version'] = $this->config->getClientVersion();
        $httpBody = new MultipartStream($multipartContents);
        $headers['Content-Type'] = "multipart/form-data; boundary=" . $httpBody->getBoundary();

        $method = 'PUT';
        $apiUrl = !$displayIntermediateResults ? '/words/batch?displayIntermediateResults=false' : '/words/batch';
        $url = ObjectSerializer::parseURL($this->config, $apiUrl, array());
        $batchRequest = new Request(
            $method,
            $url,
            $headers,
            $httpBody
        );

        if ($this->config->getDebug()) {
            $this->_writeRequestLog($method, $url, $headers, $httpBody);
        }

        return $this->client
            ->sendAsync($batchRequest, $options)
            ->then(
                function ($response) use ($requests, $displayIntermediateResults, $idToRequestMap) {
                    return ObjectSerializer::parseBatchResponse($response, $requests, $displayIntermediateResults, $idToRequestMap);
                },
                function ($e) use ($batchRequest) {
                    if ($e->getCode() == 401) {
                        $this->_requestToken();
                        throw new RepeatRequestException("Request must be retried", 401, null, null);
                    }
                    else if ($e->getCode() < 200 || $e->getCode() > 299) {
                        print($e);
                        throw new ApiException(sprintf('[%d] Error connecting to the API (%s)', $e->getCode(), $batchRequest->getUri()), $e->getCode(), null, null);
                    }
                }
            );
    }

    /*
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    private function _createHttpClientOption() 
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'w');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getTimeout() != 0)
        {
            $options[RequestOptions::TIMEOUT] = $this->config->getTimeout();
        }

        return $options;
    }

    /*
     * Executes response logging
     */
    private function _writeResponseLog($statusCode, $headers, $body)
    {
        $logInfo = "\nResponse: $statusCode \n";
        echo $logInfo . $this->_writeHeadersAndBody($logInfo, $headers, $body);
    }

    /*
     * Executes request logging
     */
    private function _writeRequestLog($method, $url, $headers, $body)
    {
        $logInfo = "\n$method: $url \n";
        echo $logInfo . $this->_writeHeadersAndBody($logInfo, $headers, $body);
    }

    /*
     * Executes header and body formatting
     */
    private function _writeHeadersAndBody($logInfo, $headers, $body)
    {
        foreach ($headers as $name => $value) {
            if (is_array($value))
            {
                $logInfo .= $name . ': ' . implode($value) . "\n";
            }
            else
            {
                $logInfo .= $name . ': ' . $value . "\n";
            }
        }

        return $logInfo .= "Body: " . $body . "\n";
    }

    /*
     * Gets a request token from server
     */
    private function _requestToken() 
    {
        $requestUrl = $this->config->getHost() . "v4.0/words/connect/token";
        $params = array(
            "grant_type"=>'client_credentials',
            "client_id" => $this->config->getClientId(),
            "client_secret" => $this->config->getClientSecret()
        );
        $multipartContents = [];
        foreach ($params as $paramName => $paramValue) {
            $multipartContents[] = [
                'name' => $paramName,
                'contents' => $paramValue
            ];
        }
        // for HTTP post (form)
        $httpBody = new MultipartStream($multipartContents);
        $response = $this->client->send(new Request('POST', $requestUrl, [], $httpBody));
        $result = json_decode($response->getBody()->getContents(), true);
        $this->config->setAccessToken($result["access_token"]);
    }

    private function _checkAuthToken()
    {
        if ($this->config->getAccessToken() === "") {
            $this->_requestToken();
        }
    }
}
